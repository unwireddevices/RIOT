From c17d804927ca81c9d9bac82fd53600802a9b099f Mon Sep 17 00:00:00 2001
From: Oleg Artamonov <oleg@unwds.com>
Date: Mon, 18 Mar 2019 15:43:24 +0300
Subject: [PATCH 1/1] KZ865 added

---
 src/mac/LoRaMac.c            |    2 +
 src/mac/LoRaMac.h            |    4 +
 src/mac/region/Region.c      |   75 ++++
 src/mac/region/RegionKZ865.c | 1021 ++++++++++++++++++++++++++++++++++++++++++
 src/mac/region/RegionKZ865.h |  467 +++++++++++++++++++
 5 files changed, 1569 insertions(+)
 create mode 100644 src/mac/region/RegionKZ865.c
 create mode 100644 src/mac/region/RegionKZ865.h

diff --git a/src/mac/LoRaMac.c b/src/mac/LoRaMac.c
index 31b9c9f..3960eb3 100644
--- a/src/mac/LoRaMac.c
+++ b/src/mac/LoRaMac.c
@@ -1819,6 +1819,7 @@ static void ProcessMacCommands( uint8_t *payload, uint8_t macIndex, uint8_t comm
                 break;
             case SRV_MAC_DUTY_CYCLE_REQ:
                 MaxDCycle = payload[macIndex++] & 0x0f;
+                printf("MAC command set MaxDCycle to %d\n", MaxDCycle);
                 AggregatedDCycle = 1 << MaxDCycle;
                 AddMacCommand( MOTE_MAC_DUTY_CYCLE_ANS, 0, 0 );
                 break;
@@ -1983,6 +1984,7 @@ static LoRaMacStatus_t ScheduleTx( bool allowDelayedTx )
     TimerTime_t dutyCycleTimeOff = 0;
     NextChanParams_t nextChan;
 
+    printf("ScheduleTX MaxDCycle is %d\n", MaxDCycle);
     if( MaxDCycle == 0 )
     {
         AggregatedTimeOff = 0;
diff --git a/src/mac/LoRaMac.h b/src/mac/LoRaMac.h
index 1bee129..a505838 100644
--- a/src/mac/LoRaMac.h
+++ b/src/mac/LoRaMac.h
@@ -1728,6 +1728,10 @@ typedef enum eLoRaMacRegion_t
      */
     LORAMAC_REGION_KR920,
     /*!
+     * Kazakhstan band on 865MHz
+     */
+    LORAMAC_REGION_KZ865,
+    /*!
      * India band on 865MHz
      */
     LORAMAC_REGION_IN865,
diff --git a/src/mac/region/Region.c b/src/mac/region/Region.c
index 7463051..cce2dec 100644
--- a/src/mac/region/Region.c
+++ b/src/mac/region/Region.c
@@ -603,6 +603,58 @@
 #define RU864_APPLY_DR_OFFSET( )
 #endif
 
+#ifdef REGION_KZ865
+#include "RegionKZ865.h"
+#define KZ865_CASE                                 case LORAMAC_REGION_KZ865:
+#define KZ865_IS_ACTIVE( )                         KZ865_CASE { return true; }
+#define KZ865_GET_PHY_PARAM( )                     KZ865_CASE { return RegionKZ865GetPhyParam( getPhy ); }
+#define KZ865_SET_BAND_TX_DONE( )                  KZ865_CASE { RegionKZ865SetBandTxDone( txDone ); break; }
+#define KZ865_INIT_DEFAULTS( )                     KZ865_CASE { RegionKZ865InitDefaults( type ); break; }
+#define KZ865_VERIFY( )                            KZ865_CASE { return RegionKZ865Verify( verify, phyAttribute ); }
+#define KZ865_APPLY_CF_LIST( )                     KZ865_CASE { RegionKZ865ApplyCFList( applyCFList ); break; }
+#define KZ865_CHAN_MASK_SET( )                     KZ865_CASE { return RegionKZ865ChanMaskSet( chanMaskSet ); }
+#define KZ865_ADR_NEXT( )                          KZ865_CASE { return RegionKZ865AdrNext( adrNext, drOut, txPowOut, adrAckCounter ); }
+#define KZ865_COMPUTE_RX_WINDOW_PARAMETERS( )      KZ865_CASE { RegionKZ865ComputeRxWindowParameters( datarate, minRxSymbols, rxError, rxConfigParams ); break; }
+#define KZ865_RX_CONFIG( )                         KZ865_CASE { return RegionKZ865RxConfig( rxConfig, datarate ); }
+#define KZ865_TX_CONFIG( )                         KZ865_CASE { return RegionKZ865TxConfig( txConfig, txPower, txTimeOnAir ); }
+#define KZ865_LINK_ADR_REQ( )                      KZ865_CASE { return RegionKZ865LinkAdrReq( linkAdrReq, drOut, txPowOut, nbRepOut, nbBytesParsed ); }
+#define KZ865_RX_PARAM_SETUP_REQ( )                KZ865_CASE { return RegionKZ865RxParamSetupReq( rxParamSetupReq ); }
+#define KZ865_NEW_CHANNEL_REQ( )                   KZ865_CASE { return RegionKZ865NewChannelReq( newChannelReq ); }
+#define KZ865_TX_PARAM_SETUP_REQ( )                KZ865_CASE { return RegionKZ865TxParamSetupReq( txParamSetupReq ); }
+#define KZ865_DL_CHANNEL_REQ( )                    KZ865_CASE { return RegionKZ865DlChannelReq( dlChannelReq ); }
+#define KZ865_ALTERNATE_DR( )                      KZ865_CASE { return RegionKZ865AlternateDr( currentDr ); }
+#define KZ865_CALC_BACKOFF( )                      KZ865_CASE { RegionKZ865CalcBackOff( calcBackOff ); break; }
+#define KZ865_NEXT_CHANNEL( )                      KZ865_CASE { return RegionKZ865NextChannel( nextChanParams, channel, time, aggregatedTimeOff ); }
+#define KZ865_CHANNEL_ADD( )                       KZ865_CASE { return RegionKZ865ChannelAdd( channelAdd ); }
+#define KZ865_CHANNEL_REMOVE( )                    KZ865_CASE { return RegionKZ865ChannelsRemove( channelRemove ); }
+#define KZ865_SET_CONTINUOUS_WAVE( )               KZ865_CASE { RegionKZ865SetContinuousWave( continuousWave ); break; }
+#define KZ865_APPLY_DR_OFFSET( )                   KZ865_CASE { return RegionKZ865ApplyDrOffset( downlinkDwellTime, dr, drOffset ); }
+#else
+#define KZ865_IS_ACTIVE( )
+#define KZ865_GET_PHY_PARAM( )
+#define KZ865_SET_BAND_TX_DONE( )
+#define KZ865_INIT_DEFAULTS( )
+#define KZ865_VERIFY( )
+#define KZ865_APPLY_CF_LIST( )
+#define KZ865_CHAN_MASK_SET( )
+#define KZ865_ADR_NEXT( )
+#define KZ865_COMPUTE_RX_WINDOW_PARAMETERS( )
+#define KZ865_RX_CONFIG( )
+#define KZ865_TX_CONFIG( )
+#define KZ865_LINK_ADR_REQ( )
+#define KZ865_RX_PARAM_SETUP_REQ( )
+#define KZ865_NEW_CHANNEL_REQ( )
+#define KZ865_TX_PARAM_SETUP_REQ( )
+#define KZ865_DL_CHANNEL_REQ( )
+#define KZ865_ALTERNATE_DR( )
+#define KZ865_CALC_BACKOFF( )
+#define KZ865_NEXT_CHANNEL( )
+#define KZ865_CHANNEL_ADD( )
+#define KZ865_CHANNEL_REMOVE( )
+#define KZ865_SET_CONTINUOUS_WAVE( )
+#define KZ865_APPLY_DR_OFFSET( )
+#endif
+
 bool RegionIsActive( LoRaMacRegion_t region )
 {
     switch( region )
@@ -614,6 +666,7 @@ bool RegionIsActive( LoRaMacRegion_t region )
         EU433_IS_ACTIVE( );
         EU868_IS_ACTIVE( );
         KR920_IS_ACTIVE( );
+        KZ865_IS_ACTIVE( );
         IN865_IS_ACTIVE( );
         US915_IS_ACTIVE( );
         RU864_IS_ACTIVE( );
@@ -637,6 +690,7 @@ PhyParam_t RegionGetPhyParam( LoRaMacRegion_t region, GetPhyParams_t* getPhy )
         EU433_GET_PHY_PARAM( );
         EU868_GET_PHY_PARAM( );
         KR920_GET_PHY_PARAM( );
+        KZ865_GET_PHY_PARAM( );
         IN865_GET_PHY_PARAM( );
         US915_GET_PHY_PARAM( );
         RU864_GET_PHY_PARAM( );
@@ -659,6 +713,7 @@ void RegionSetBandTxDone( LoRaMacRegion_t region, SetBandTxDoneParams_t* txDone
         EU433_SET_BAND_TX_DONE( );
         EU868_SET_BAND_TX_DONE( );
         KR920_SET_BAND_TX_DONE( );
+        KZ865_SET_BAND_TX_DONE( );
         IN865_SET_BAND_TX_DONE( );
         US915_SET_BAND_TX_DONE( );
         RU864_SET_BAND_TX_DONE( );
@@ -681,6 +736,7 @@ void RegionInitDefaults( LoRaMacRegion_t region, InitType_t type )
         EU433_INIT_DEFAULTS( );
         EU868_INIT_DEFAULTS( );
         KR920_INIT_DEFAULTS( );
+        KZ865_INIT_DEFAULTS( );
         IN865_INIT_DEFAULTS( );
         US915_INIT_DEFAULTS( );
         RU864_INIT_DEFAULTS( );
@@ -703,6 +759,7 @@ bool RegionVerify( LoRaMacRegion_t region, VerifyParams_t* verify, PhyAttribute_
         EU433_VERIFY( );
         EU868_VERIFY( );
         KR920_VERIFY( );
+        KZ865_VERIFY( );
         IN865_VERIFY( );
         US915_VERIFY( );
         RU864_VERIFY( );
@@ -725,6 +782,7 @@ void RegionApplyCFList( LoRaMacRegion_t region, ApplyCFListParams_t* applyCFList
         EU433_APPLY_CF_LIST( );
         EU868_APPLY_CF_LIST( );
         KR920_APPLY_CF_LIST( );
+        KZ865_APPLY_CF_LIST( );
         IN865_APPLY_CF_LIST( );
         US915_APPLY_CF_LIST( );
         RU864_APPLY_CF_LIST( );
@@ -747,6 +805,7 @@ bool RegionChanMaskSet( LoRaMacRegion_t region, ChanMaskSetParams_t* chanMaskSet
         EU433_CHAN_MASK_SET( );
         EU868_CHAN_MASK_SET( );
         KR920_CHAN_MASK_SET( );
+        KZ865_CHAN_MASK_SET( );
         IN865_CHAN_MASK_SET( );
         US915_CHAN_MASK_SET( );
         RU864_CHAN_MASK_SET( );
@@ -769,6 +828,7 @@ bool RegionAdrNext( LoRaMacRegion_t region, AdrNextParams_t* adrNext, int8_t* dr
         EU433_ADR_NEXT( );
         EU868_ADR_NEXT( );
         KR920_ADR_NEXT( );
+        KZ865_ADR_NEXT( );
         IN865_ADR_NEXT( );
         US915_ADR_NEXT( );
         RU864_ADR_NEXT( );
@@ -791,6 +851,7 @@ void RegionComputeRxWindowParameters( LoRaMacRegion_t region, int8_t datarate, u
         EU433_COMPUTE_RX_WINDOW_PARAMETERS( );
         EU868_COMPUTE_RX_WINDOW_PARAMETERS( );
         KR920_COMPUTE_RX_WINDOW_PARAMETERS( );
+        KZ865_COMPUTE_RX_WINDOW_PARAMETERS( );
         IN865_COMPUTE_RX_WINDOW_PARAMETERS( );
         US915_COMPUTE_RX_WINDOW_PARAMETERS( );
         RU864_COMPUTE_RX_WINDOW_PARAMETERS( );
@@ -813,6 +874,7 @@ bool RegionRxConfig( LoRaMacRegion_t region, RxConfigParams_t* rxConfig, int8_t*
         EU433_RX_CONFIG( );
         EU868_RX_CONFIG( );
         KR920_RX_CONFIG( );
+        KZ865_RX_CONFIG( );
         IN865_RX_CONFIG( );
         US915_RX_CONFIG( );
         RU864_RX_CONFIG( );
@@ -835,6 +897,7 @@ bool RegionTxConfig( LoRaMacRegion_t region, TxConfigParams_t* txConfig, int8_t*
         EU433_TX_CONFIG( );
         EU868_TX_CONFIG( );
         KR920_TX_CONFIG( );
+        KZ865_TX_CONFIG( );
         IN865_TX_CONFIG( );
         US915_TX_CONFIG( );
         RU864_TX_CONFIG( );
@@ -857,6 +920,7 @@ uint8_t RegionLinkAdrReq( LoRaMacRegion_t region, LinkAdrReqParams_t* linkAdrReq
         EU433_LINK_ADR_REQ( );
         EU868_LINK_ADR_REQ( );
         KR920_LINK_ADR_REQ( );
+        KZ865_LINK_ADR_REQ( );
         IN865_LINK_ADR_REQ( );
         US915_LINK_ADR_REQ( );
         RU864_LINK_ADR_REQ( );
@@ -879,6 +943,7 @@ uint8_t RegionRxParamSetupReq( LoRaMacRegion_t region, RxParamSetupReqParams_t*
         EU433_RX_PARAM_SETUP_REQ( );
         EU868_RX_PARAM_SETUP_REQ( );
         KR920_RX_PARAM_SETUP_REQ( );
+        KZ865_RX_PARAM_SETUP_REQ( );
         IN865_RX_PARAM_SETUP_REQ( );
         US915_RX_PARAM_SETUP_REQ( );
         RU864_RX_PARAM_SETUP_REQ( );
@@ -901,6 +966,7 @@ uint8_t RegionNewChannelReq( LoRaMacRegion_t region, NewChannelReqParams_t* newC
         EU433_NEW_CHANNEL_REQ( );
         EU868_NEW_CHANNEL_REQ( );
         KR920_NEW_CHANNEL_REQ( );
+        KZ865_NEW_CHANNEL_REQ( );
         IN865_NEW_CHANNEL_REQ( );
         US915_NEW_CHANNEL_REQ( );
         RU864_NEW_CHANNEL_REQ( );
@@ -923,6 +989,7 @@ int8_t RegionTxParamSetupReq( LoRaMacRegion_t region, TxParamSetupReqParams_t* t
         EU433_TX_PARAM_SETUP_REQ( );
         EU868_TX_PARAM_SETUP_REQ( );
         KR920_TX_PARAM_SETUP_REQ( );
+        KZ865_TX_PARAM_SETUP_REQ( );
         IN865_TX_PARAM_SETUP_REQ( );
         US915_TX_PARAM_SETUP_REQ( );
         RU864_TX_PARAM_SETUP_REQ( );
@@ -945,6 +1012,7 @@ uint8_t RegionDlChannelReq( LoRaMacRegion_t region, DlChannelReqParams_t* dlChan
         EU433_DL_CHANNEL_REQ( );
         EU868_DL_CHANNEL_REQ( );
         KR920_DL_CHANNEL_REQ( );
+        KZ865_DL_CHANNEL_REQ( );
         IN865_DL_CHANNEL_REQ( );
         US915_DL_CHANNEL_REQ( );
         RU864_DL_CHANNEL_REQ( );
@@ -967,6 +1035,7 @@ int8_t RegionAlternateDr( LoRaMacRegion_t region, int8_t currentDr )
         EU433_ALTERNATE_DR( );
         EU868_ALTERNATE_DR( );
         KR920_ALTERNATE_DR( );
+        KZ865_ALTERNATE_DR( );
         IN865_ALTERNATE_DR( );
         US915_ALTERNATE_DR( );
         RU864_ALTERNATE_DR( );
@@ -989,6 +1058,7 @@ void RegionCalcBackOff( LoRaMacRegion_t region, CalcBackOffParams_t* calcBackOff
         EU433_CALC_BACKOFF( );
         EU868_CALC_BACKOFF( );
         KR920_CALC_BACKOFF( );
+        KZ865_CALC_BACKOFF( );
         IN865_CALC_BACKOFF( );
         US915_CALC_BACKOFF( );
         RU864_CALC_BACKOFF( );
@@ -1011,6 +1081,7 @@ LoRaMacStatus_t RegionNextChannel( LoRaMacRegion_t region, NextChanParams_t* nex
         EU433_NEXT_CHANNEL( );
         EU868_NEXT_CHANNEL( );
         KR920_NEXT_CHANNEL( );
+        KZ865_NEXT_CHANNEL( );
         IN865_NEXT_CHANNEL( );
         US915_NEXT_CHANNEL( );
         RU864_NEXT_CHANNEL( );
@@ -1033,6 +1104,7 @@ LoRaMacStatus_t RegionChannelAdd( LoRaMacRegion_t region, ChannelAddParams_t* ch
         EU433_CHANNEL_ADD( );
         EU868_CHANNEL_ADD( );
         KR920_CHANNEL_ADD( );
+        KZ865_CHANNEL_ADD( );
         IN865_CHANNEL_ADD( );
         US915_CHANNEL_ADD( );
         RU864_CHANNEL_ADD( );
@@ -1055,6 +1127,7 @@ bool RegionChannelsRemove( LoRaMacRegion_t region, ChannelRemoveParams_t* channe
         EU433_CHANNEL_REMOVE( );
         EU868_CHANNEL_REMOVE( );
         KR920_CHANNEL_REMOVE( );
+        KZ865_CHANNEL_REMOVE( );
         IN865_CHANNEL_REMOVE( );
         US915_CHANNEL_REMOVE( );
         RU864_CHANNEL_REMOVE( );
@@ -1077,6 +1150,7 @@ void RegionSetContinuousWave( LoRaMacRegion_t region, ContinuousWaveParams_t* co
         EU433_SET_CONTINUOUS_WAVE( );
         EU868_SET_CONTINUOUS_WAVE( );
         KR920_SET_CONTINUOUS_WAVE( );
+        KZ865_SET_CONTINUOUS_WAVE( );
         IN865_SET_CONTINUOUS_WAVE( );
         US915_SET_CONTINUOUS_WAVE( );
         RU864_SET_CONTINUOUS_WAVE( );
@@ -1099,6 +1173,7 @@ uint8_t RegionApplyDrOffset( LoRaMacRegion_t region, uint8_t downlinkDwellTime,
         EU433_APPLY_DR_OFFSET( );
         EU868_APPLY_DR_OFFSET( );
         KR920_APPLY_DR_OFFSET( );
+        KZ865_APPLY_DR_OFFSET( );
         IN865_APPLY_DR_OFFSET( );
         US915_APPLY_DR_OFFSET( );
         RU864_APPLY_DR_OFFSET( );
diff --git a/src/mac/region/RegionKZ865.c b/src/mac/region/RegionKZ865.c
new file mode 100644
index 0000000..c06aa9f
--- /dev/null
+++ b/src/mac/region/RegionKZ865.c
@@ -0,0 +1,1021 @@
+/*!
+ * \file      RegionKZ865.c
+ *
+ * \brief     Region implementation for KZ865
+ *
+ * \copyright Revised BSD License, see section \ref LICENSE.
+ *
+ * \code
+ *                ______                              _
+ *               / _____)             _              | |
+ *              ( (____  _____ ____ _| |_ _____  ____| |__
+ *               \____ \| ___ |    (_   _) ___ |/ ___)  _ \
+ *               _____) ) ____| | | || |_| ____( (___| | | |
+ *              (______/|_____)_|_|_| \__)_____)\____)_| |_|
+ *              (C)2013-2017 Semtech
+ *
+ *               ___ _____ _   ___ _  _____ ___  ___  ___ ___
+ *              / __|_   _/_\ / __| |/ / __/ _ \| _ \/ __| __|
+ *              \__ \ | |/ _ \ (__| ' <| _| (_) |   / (__| _|
+ *              |___/ |_/_/ \_\___|_|\_\_| \___/|_|_\\___|___|
+ *              embedded.connectivity.solutions===============
+ *
+ * \endcode
+ *
+ * \author    Miguel Luis ( Semtech )
+ *
+ * \author    Gregory Cristian ( Semtech )
+ *
+ * \author    Daniel Jaeckle ( STACKFORCE )
+ *
+ * \author    Oleg Artamonov ( Unwired Devices )
+*/
+#include "boards/utilities.h"
+
+#include "RegionCommon.h"
+#include "RegionKZ865.h"
+
+// Definitions
+#define CHANNELS_MASK_SIZE              1
+
+// Global attributes
+/*!
+ * LoRaMAC channels
+ */
+static ChannelParams_t Channels[KZ865_MAX_NB_CHANNELS];
+
+/*!
+ * LoRaMac bands
+ */
+static Band_t Bands[KZ865_MAX_NB_BANDS] =
+{
+    KZ865_BAND0,
+};
+
+/*!
+ * LoRaMac channels mask
+ */
+static uint16_t ChannelsMask[CHANNELS_MASK_SIZE];
+
+/*!
+ * LoRaMac channels default mask
+ */
+static uint16_t ChannelsDefaultMask[CHANNELS_MASK_SIZE];
+
+// Static functions
+static int8_t GetNextLowerTxDr( int8_t dr, int8_t minDr )
+{
+    uint8_t nextLowerDr = 0;
+
+    if( dr == minDr )
+    {
+        nextLowerDr = minDr;
+    }
+    else
+    {
+        nextLowerDr = dr - 1;
+    }
+    return nextLowerDr;
+}
+
+static uint32_t GetBandwidth( uint32_t drIndex )
+{
+    switch( BandwidthsKZ865[drIndex] )
+    {
+        default:
+        case 125000:
+            return 0;
+        case 250000:
+            return 1;
+        case 500000:
+            return 2;
+    }
+}
+
+static int8_t LimitTxPower( int8_t txPower, int8_t maxBandTxPower, int8_t datarate, uint16_t* channelsMask )
+{
+    int8_t txPowerResult = txPower;
+
+    // Limit tx power to the band max
+    txPowerResult =  MAX( txPower, maxBandTxPower );
+
+    return txPowerResult;
+}
+
+static bool VerifyTxFreq( uint32_t freq, uint8_t *band )
+{
+    // Check radio driver support
+    if( Radio.CheckRfFrequency( freq ) == false )
+    {
+        return false;
+    }
+
+    // Check frequency bands
+    if( ( freq >= 865000000 ) && ( freq <= 868000000 ) )
+    {
+        *band = 0;
+    }
+    else
+    {
+        return false;
+    }
+    return true;
+}
+
+static uint8_t CountNbOfEnabledChannels( bool joined, uint8_t datarate, uint16_t* channelsMask, ChannelParams_t* channels, Band_t* bands, uint8_t* enabledChannels, uint8_t* delayTx )
+{
+    uint8_t nbEnabledChannels = 0;
+    uint8_t delayTransmission = 0;
+
+    for( uint8_t i = 0, k = 0; i < KZ865_MAX_NB_CHANNELS; i += 16, k++ )
+    {
+        for( uint8_t j = 0; j < 16; j++ )
+        {
+            if( ( channelsMask[k] & ( 1 << j ) ) != 0 )
+            {
+                if( channels[i + j].Frequency == 0 )
+                { // Check if the channel is enabled
+                    continue;
+                }
+                if( joined == false )
+                {
+                    if( ( KZ865_JOIN_CHANNELS & ( 1 << j ) ) == 0 )
+                    {
+                        continue;
+                    }
+                }
+                if( RegionCommonValueInRange( datarate, channels[i + j].DrRange.Fields.Min,
+                                              channels[i + j].DrRange.Fields.Max ) == false )
+                { // Check if the current channel selection supports the given datarate
+                    continue;
+                }
+                if( bands[channels[i + j].Band].TimeOff > 0 )
+                { // Check if the band is available for transmission
+                    delayTransmission++;
+                    continue;
+                }
+                enabledChannels[nbEnabledChannels++] = i + j;
+            }
+        }
+    }
+
+    *delayTx = delayTransmission;
+    return nbEnabledChannels;
+}
+
+PhyParam_t RegionKZ865GetPhyParam( GetPhyParams_t* getPhy )
+{
+    PhyParam_t phyParam = { 0 };
+
+    switch( getPhy->Attribute )
+    {
+        case PHY_MIN_RX_DR:
+        {
+            phyParam.Value = KZ865_RX_MIN_DATARATE;
+            break;
+        }
+        case PHY_MIN_TX_DR:
+        {
+            phyParam.Value = KZ865_TX_MIN_DATARATE;
+            break;
+        }
+        case PHY_DEF_TX_DR:
+        {
+            phyParam.Value = KZ865_DEFAULT_DATARATE;
+            break;
+        }
+        case PHY_NEXT_LOWER_TX_DR:
+        {
+            phyParam.Value = GetNextLowerTxDr( getPhy->Datarate, KZ865_TX_MIN_DATARATE );
+            break;
+        }
+        case PHY_DEF_TX_POWER:
+        {
+            phyParam.Value = KZ865_DEFAULT_TX_POWER;
+            break;
+        }
+        case PHY_MAX_PAYLOAD:
+        {
+            phyParam.Value = MaxPayloadOfDatarateKZ865[getPhy->Datarate];
+            break;
+        }
+        case PHY_MAX_PAYLOAD_REPEATER:
+        {
+            phyParam.Value = MaxPayloadOfDatarateRepeaterKZ865[getPhy->Datarate];
+            break;
+        }
+        case PHY_DUTY_CYCLE:
+        {
+            phyParam.Value = KZ865_DUTY_CYCLE_ENABLED;
+            break;
+        }
+        case PHY_MAX_RX_WINDOW:
+        {
+            phyParam.Value = KZ865_MAX_RX_WINDOW;
+            break;
+        }
+        case PHY_RECEIVE_DELAY1:
+        {
+            phyParam.Value = KZ865_RECEIVE_DELAY1;
+            break;
+        }
+        case PHY_RECEIVE_DELAY2:
+        {
+            phyParam.Value = KZ865_RECEIVE_DELAY2;
+            break;
+        }
+        case PHY_JOIN_ACCEPT_DELAY1:
+        {
+            phyParam.Value = KZ865_JOIN_ACCEPT_DELAY1;
+            break;
+        }
+        case PHY_JOIN_ACCEPT_DELAY2:
+        {
+            phyParam.Value = KZ865_JOIN_ACCEPT_DELAY2;
+            break;
+        }
+        case PHY_MAX_FCNT_GAP:
+        {
+            phyParam.Value = KZ865_MAX_FCNT_GAP;
+            break;
+        }
+        case PHY_ACK_TIMEOUT:
+        {
+            phyParam.Value = ( KZ865_ACKTIMEOUT + randr( -KZ865_ACK_TIMEOUT_RND, KZ865_ACK_TIMEOUT_RND ) );
+            break;
+        }
+        case PHY_DEF_DR1_OFFSET:
+        {
+            phyParam.Value = KZ865_DEFAULT_RX1_DR_OFFSET;
+            break;
+        }
+        case PHY_DEF_RX2_FREQUENCY:
+        {
+            phyParam.Value = KZ865_RX_WND_2_FREQ;
+            break;
+        }
+        case PHY_DEF_RX2_DR:
+        {
+            phyParam.Value = KZ865_RX_WND_2_DR;
+            break;
+        }
+        case PHY_CHANNELS_MASK:
+        {
+            phyParam.ChannelsMask = ChannelsMask;
+            break;
+        }
+        case PHY_CHANNELS_DEFAULT_MASK:
+        {
+            phyParam.ChannelsMask = ChannelsDefaultMask;
+            break;
+        }
+        case PHY_MAX_NB_CHANNELS:
+        {
+            phyParam.Value = KZ865_MAX_NB_CHANNELS;
+            break;
+        }
+        case PHY_CHANNELS:
+        {
+            phyParam.Channels = Channels;
+            break;
+        }
+        case PHY_DEF_UPLINK_DWELL_TIME:
+        case PHY_DEF_DOWNLINK_DWELL_TIME:
+        {
+            phyParam.Value = 0;
+            break;
+        }
+        case PHY_DEF_MAX_EIRP:
+        {
+            phyParam.fValue = KZ865_DEFAULT_MAX_EIRP;
+            break;
+        }
+        case PHY_DEF_ANTENNA_GAIN:
+        {
+            phyParam.fValue = KZ865_DEFAULT_ANTENNA_GAIN;
+            break;
+        }
+        default:
+        {
+            break;
+        }
+    }
+
+    return phyParam;
+}
+
+void RegionKZ865SetBandTxDone( SetBandTxDoneParams_t* txDone )
+{
+    RegionCommonSetBandTxDone( txDone->Joined, &Bands[Channels[txDone->Channel].Band], txDone->LastTxDoneTime );
+}
+
+void RegionKZ865InitDefaults( InitType_t type )
+{
+    switch( type )
+    {
+        case INIT_TYPE_INIT:
+        {
+            // Channels
+            Channels[0] = ( ChannelParams_t ) KZ865_LC1;
+            Channels[1] = ( ChannelParams_t ) KZ865_LC2;
+            Channels[2] = ( ChannelParams_t ) KZ865_LC3;
+
+            // Initialize the channels default mask
+            ChannelsDefaultMask[0] = LC( 1 ) + LC( 2 ) + LC( 3 );
+            // Update the channels mask
+            RegionCommonChanMaskCopy( ChannelsMask, ChannelsDefaultMask, 1 );
+            break;
+        }
+        case INIT_TYPE_RESTORE:
+        {
+            // Restore channels default mask
+            ChannelsMask[0] |= ChannelsDefaultMask[0];
+            break;
+        }
+        case INIT_TYPE_APP_DEFAULTS:
+        {
+            // Update the channels mask defaults
+            RegionCommonChanMaskCopy( ChannelsMask, ChannelsDefaultMask, 1 );
+            break;
+        }
+        default:
+        {
+            break;
+        }
+    }
+}
+
+bool RegionKZ865Verify( VerifyParams_t* verify, PhyAttribute_t phyAttribute )
+{
+    switch( phyAttribute )
+    {
+        case PHY_TX_DR:
+        {
+            return RegionCommonValueInRange( verify->DatarateParams.Datarate, KZ865_TX_MIN_DATARATE, KZ865_TX_MAX_DATARATE );
+        }
+        case PHY_DEF_TX_DR:
+        {
+            return RegionCommonValueInRange( verify->DatarateParams.Datarate, DR_0, DR_5 );
+        }
+        case PHY_RX_DR:
+        {
+            return RegionCommonValueInRange( verify->DatarateParams.Datarate, KZ865_RX_MIN_DATARATE, KZ865_RX_MAX_DATARATE );
+        }
+        case PHY_DEF_TX_POWER:
+        case PHY_TX_POWER:
+        {
+            // Remark: switched min and max!
+            return RegionCommonValueInRange( verify->TxPower, KZ865_MAX_TX_POWER, KZ865_MIN_TX_POWER );
+        }
+        case PHY_DUTY_CYCLE:
+        {
+            return KZ865_DUTY_CYCLE_ENABLED;
+        }
+        default:
+            return false;
+    }
+}
+
+void RegionKZ865ApplyCFList( ApplyCFListParams_t* applyCFList )
+{
+    ChannelParams_t newChannel;
+    ChannelAddParams_t channelAdd;
+    ChannelRemoveParams_t channelRemove;
+
+    // Setup default datarate range
+    newChannel.DrRange.Value = ( DR_5 << 4 ) | DR_0;
+
+    // Size of the optional CF list
+    if( applyCFList->Size != 16 )
+    {
+        return;
+    }
+
+    // Last byte is RFU, don't take it into account
+    for( uint8_t i = 0, chanIdx = KZ865_NUMB_DEFAULT_CHANNELS; chanIdx < KZ865_MAX_NB_CHANNELS; i+=3, chanIdx++ )
+    {
+        if( chanIdx < ( KZ865_NUMB_CHANNELS_CF_LIST + KZ865_NUMB_DEFAULT_CHANNELS ) )
+        {
+            // Channel frequency
+            newChannel.Frequency = (uint32_t) applyCFList->Payload[i];
+            newChannel.Frequency |= ( (uint32_t) applyCFList->Payload[i + 1] << 8 );
+            newChannel.Frequency |= ( (uint32_t) applyCFList->Payload[i + 2] << 16 );
+            newChannel.Frequency *= 100;
+
+            // Initialize alternative frequency to 0
+            newChannel.Rx1Frequency = 0;
+        }
+        else
+        {
+            newChannel.Frequency = 0;
+            newChannel.DrRange.Value = 0;
+            newChannel.Rx1Frequency = 0;
+        }
+
+        if( newChannel.Frequency != 0 )
+        {
+            channelAdd.NewChannel = &newChannel;
+            channelAdd.ChannelId = chanIdx;
+
+            // Try to add all channels
+            RegionKZ865ChannelAdd( &channelAdd );
+        }
+        else
+        {
+            channelRemove.ChannelId = chanIdx;
+
+            RegionKZ865ChannelsRemove( &channelRemove );
+        }
+    }
+}
+
+bool RegionKZ865ChanMaskSet( ChanMaskSetParams_t* chanMaskSet )
+{
+    switch( chanMaskSet->ChannelsMaskType )
+    {
+        case CHANNELS_MASK:
+        {
+            RegionCommonChanMaskCopy( ChannelsMask, chanMaskSet->ChannelsMaskIn, 1 );
+            break;
+        }
+        case CHANNELS_DEFAULT_MASK:
+        {
+            RegionCommonChanMaskCopy( ChannelsDefaultMask, chanMaskSet->ChannelsMaskIn, 1 );
+            break;
+        }
+        default:
+            return false;
+    }
+    return true;
+}
+
+bool RegionKZ865AdrNext( AdrNextParams_t* adrNext, int8_t* drOut, int8_t* txPowOut, uint32_t* adrAckCounter )
+{
+    bool adrAckReq = false;
+    int8_t datarate = adrNext->Datarate;
+    int8_t txPower = adrNext->TxPower;
+    GetPhyParams_t getPhy;
+    PhyParam_t phyParam;
+
+    // Report back the adr ack counter
+    *adrAckCounter = adrNext->AdrAckCounter;
+
+    if( adrNext->AdrEnabled == true )
+    {
+        if( datarate == KZ865_TX_MIN_DATARATE )
+        {
+            *adrAckCounter = 0;
+            adrAckReq = false;
+        }
+        else
+        {
+            if( adrNext->AdrAckCounter >= KZ865_ADR_ACK_LIMIT )
+            {
+                adrAckReq = true;
+                txPower = KZ865_MAX_TX_POWER;
+            }
+            else
+            {
+                adrAckReq = false;
+            }
+            if( adrNext->AdrAckCounter >= ( KZ865_ADR_ACK_LIMIT + KZ865_ADR_ACK_DELAY ) )
+            {
+                if( ( adrNext->AdrAckCounter % KZ865_ADR_ACK_DELAY ) == 1 )
+                {
+                    // Decrease the datarate
+                    getPhy.Attribute = PHY_NEXT_LOWER_TX_DR;
+                    getPhy.Datarate = datarate;
+                    getPhy.UplinkDwellTime = adrNext->UplinkDwellTime;
+                    phyParam = RegionKZ865GetPhyParam( &getPhy );
+                    datarate = phyParam.Value;
+
+                    if( datarate == KZ865_TX_MIN_DATARATE )
+                    {
+                        // We must set adrAckReq to false as soon as we reach the lowest datarate
+                        adrAckReq = false;
+                        if( adrNext->UpdateChanMask == true )
+                        {
+                            // Re-enable default channels
+                            ChannelsMask[0] |= LC( 1 ) + LC( 2 ) + LC( 3 );
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    *drOut = datarate;
+    *txPowOut = txPower;
+    return adrAckReq;
+}
+
+void RegionKZ865ComputeRxWindowParameters( int8_t datarate, uint8_t minRxSymbols, uint32_t rxError, RxConfigParams_t *rxConfigParams )
+{
+    double tSymbol = 0.0;
+
+    // Get the datarate, perform a boundary check
+    rxConfigParams->Datarate = MIN( datarate, KZ865_RX_MAX_DATARATE );
+    rxConfigParams->Bandwidth = GetBandwidth( rxConfigParams->Datarate );
+
+    if( rxConfigParams->Datarate == DR_7 )
+    { // FSK
+        tSymbol = RegionCommonComputeSymbolTimeFsk( DataratesKZ865[rxConfigParams->Datarate] );
+    }
+    else
+    { // LoRa
+        tSymbol = RegionCommonComputeSymbolTimeLoRa( DataratesKZ865[rxConfigParams->Datarate], BandwidthsKZ865[rxConfigParams->Datarate] );
+    }
+
+    RegionCommonComputeRxWindowParameters( tSymbol, minRxSymbols, rxError, Radio.GetWakeupTime( ), &rxConfigParams->WindowTimeout, &rxConfigParams->WindowOffset );
+}
+
+bool RegionKZ865RxConfig( RxConfigParams_t* rxConfig, int8_t* datarate )
+{
+    RadioModems_t modem;
+    int8_t dr = rxConfig->Datarate;
+    uint8_t maxPayload = 0;
+    int8_t phyDr = 0;
+    uint32_t frequency = rxConfig->Frequency;
+
+    if( Radio.GetStatus( ) != RF_IDLE )
+    {
+        return false;
+    }
+
+    if( rxConfig->RxSlot == RX_SLOT_WIN_1 )
+    {
+        // Apply window 1 frequency
+        frequency = Channels[rxConfig->Channel].Frequency;
+        // Apply the alternative RX 1 window frequency, if it is available
+        if( Channels[rxConfig->Channel].Rx1Frequency != 0 )
+        {
+            frequency = Channels[rxConfig->Channel].Rx1Frequency;
+        }
+    }
+
+    // Read the physical datarate from the datarates table
+    phyDr = DataratesKZ865[dr];
+
+    Radio.SetChannel( frequency );
+
+    // Radio configuration
+    if( dr == DR_7 )
+    {
+        modem = MODEM_FSK;
+        Radio.SetRxConfig( modem, 50000, phyDr * 1000, 0, 83333, 5, rxConfig->WindowTimeout, false, 0, true, 0, 0, false, rxConfig->RxContinuous );
+    }
+    else
+    {
+        modem = MODEM_LORA;
+        Radio.SetRxConfig( modem, rxConfig->Bandwidth, phyDr, 1, 0, 8, rxConfig->WindowTimeout, false, 0, false, 0, 0, true, rxConfig->RxContinuous );
+    }
+
+    if( rxConfig->RepeaterSupport == true )
+    {
+        maxPayload = MaxPayloadOfDatarateRepeaterKZ865[dr];
+    }
+    else
+    {
+        maxPayload = MaxPayloadOfDatarateKZ865[dr];
+    }
+
+    Radio.SetMaxPayloadLength( modem, maxPayload + LORA_MAC_FRMPAYLOAD_OVERHEAD );
+
+    *datarate = (uint8_t) dr;
+    return true;
+}
+
+bool RegionKZ865TxConfig( TxConfigParams_t* txConfig, int8_t* txPower, TimerTime_t* txTimeOnAir )
+{
+    RadioModems_t modem;
+    int8_t phyDr = DataratesKZ865[txConfig->Datarate];
+    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, Bands[Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, ChannelsMask );
+    uint32_t bandwidth = GetBandwidth( txConfig->Datarate );
+    int8_t phyTxPower = 0;
+
+    // Calculate physical TX power
+    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, txConfig->MaxEirp, txConfig->AntennaGain );
+
+    // Setup the radio frequency
+    Radio.SetChannel( Channels[txConfig->Channel].Frequency );
+
+    if( txConfig->Datarate == DR_7 )
+    { // High Speed FSK channel
+        modem = MODEM_FSK;
+        Radio.SetTxConfig( modem, phyTxPower, 25000, bandwidth, phyDr * 1000, 0, 5, false, true, 0, 0, false, 3000 );
+    }
+    else
+    {
+        modem = MODEM_LORA;
+        Radio.SetTxConfig( modem, phyTxPower, 0, bandwidth, phyDr, 1, 8, false, true, 0, 0, false, 3000 );
+    }
+
+    // Setup maximum payload lenght of the radio driver
+    Radio.SetMaxPayloadLength( modem, txConfig->PktLen );
+    // Get the time-on-air of the next tx frame
+    *txTimeOnAir = Radio.TimeOnAir( modem, txConfig->PktLen );
+
+    *txPower = txPowerLimited;
+    return true;
+}
+
+uint8_t RegionKZ865LinkAdrReq( LinkAdrReqParams_t* linkAdrReq, int8_t* drOut, int8_t* txPowOut, uint8_t* nbRepOut, uint8_t* nbBytesParsed )
+{
+    uint8_t status = 0x07;
+    RegionCommonLinkAdrParams_t linkAdrParams;
+    uint8_t nextIndex = 0;
+    uint8_t bytesProcessed = 0;
+    uint16_t chMask = 0;
+    GetPhyParams_t getPhy;
+    PhyParam_t phyParam;
+    RegionCommonLinkAdrReqVerifyParams_t linkAdrVerifyParams;
+
+    while( bytesProcessed < linkAdrReq->PayloadSize )
+    {
+        // Get ADR request parameters
+        nextIndex = RegionCommonParseLinkAdrReq( &( linkAdrReq->Payload[bytesProcessed] ), &linkAdrParams );
+
+        if( nextIndex == 0 )
+            break; // break loop, since no more request has been found
+
+        // Update bytes processed
+        bytesProcessed += nextIndex;
+
+        // Revert status, as we only check the last ADR request for the channel mask KO
+        status = 0x07;
+
+        // Setup temporary channels mask
+        chMask = linkAdrParams.ChMask;
+
+        // Verify channels mask
+        if( ( linkAdrParams.ChMaskCtrl == 0 ) && ( chMask == 0 ) )
+        {
+            status &= 0xFE; // Channel mask KO
+        }
+        else if( ( ( linkAdrParams.ChMaskCtrl >= 1 ) && ( linkAdrParams.ChMaskCtrl <= 5 )) ||
+                ( linkAdrParams.ChMaskCtrl >= 7 ) )
+        {
+            // RFU
+            status &= 0xFE; // Channel mask KO
+        }
+        else
+        {
+            for( uint8_t i = 0; i < KZ865_MAX_NB_CHANNELS; i++ )
+            {
+                if( linkAdrParams.ChMaskCtrl == 6 )
+                {
+                    if( Channels[i].Frequency != 0 )
+                    {
+                        chMask |= 1 << i;
+                    }
+                }
+                else
+                {
+                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
+                        ( Channels[i].Frequency == 0 ) )
+                    {// Trying to enable an undefined channel
+                        status &= 0xFE; // Channel mask KO
+                    }
+                }
+            }
+        }
+    }
+
+    // Get the minimum possible datarate
+    getPhy.Attribute = PHY_MIN_TX_DR;
+    getPhy.UplinkDwellTime = linkAdrReq->UplinkDwellTime;
+    phyParam = RegionKZ865GetPhyParam( &getPhy );
+
+    linkAdrVerifyParams.Status = status;
+    linkAdrVerifyParams.AdrEnabled = linkAdrReq->AdrEnabled;
+    linkAdrVerifyParams.Datarate = linkAdrParams.Datarate;
+    linkAdrVerifyParams.TxPower = linkAdrParams.TxPower;
+    linkAdrVerifyParams.NbRep = linkAdrParams.NbRep;
+    linkAdrVerifyParams.CurrentDatarate = linkAdrReq->CurrentDatarate;
+    linkAdrVerifyParams.CurrentTxPower = linkAdrReq->CurrentTxPower;
+    linkAdrVerifyParams.CurrentNbRep = linkAdrReq->CurrentNbRep;
+    linkAdrVerifyParams.NbChannels = KZ865_MAX_NB_CHANNELS;
+    linkAdrVerifyParams.ChannelsMask = &chMask;
+    linkAdrVerifyParams.MinDatarate = ( int8_t )phyParam.Value;
+    linkAdrVerifyParams.MaxDatarate = KZ865_TX_MAX_DATARATE;
+    linkAdrVerifyParams.Channels = Channels;
+    linkAdrVerifyParams.MinTxPower = KZ865_MIN_TX_POWER;
+    linkAdrVerifyParams.MaxTxPower = KZ865_MAX_TX_POWER;
+
+    // Verify the parameters and update, if necessary
+    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
+
+    // Update channelsMask if everything is correct
+    if( status == 0x07 )
+    {
+        // Set the channels mask to a default value
+        memset1( ( uint8_t* )ChannelsMask, 0, sizeof( ChannelsMask ) );
+        // Update the channels mask
+        ChannelsMask[0] = chMask;
+    }
+
+    // Update status variables
+    *drOut = linkAdrParams.Datarate;
+    *txPowOut = linkAdrParams.TxPower;
+    *nbRepOut = linkAdrParams.NbRep;
+    *nbBytesParsed = bytesProcessed;
+
+    return status;
+}
+
+uint8_t RegionKZ865RxParamSetupReq( RxParamSetupReqParams_t* rxParamSetupReq )
+{
+    uint8_t status = 0x07;
+
+    // Verify radio frequency
+    if( Radio.CheckRfFrequency( rxParamSetupReq->Frequency ) == false )
+    {
+        status &= 0xFE; // Channel frequency KO
+    }
+
+    // Verify datarate
+    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, KZ865_RX_MIN_DATARATE, KZ865_RX_MAX_DATARATE ) == false )
+    {
+        status &= 0xFD; // Datarate KO
+    }
+
+    // Verify datarate offset
+    if( RegionCommonValueInRange( rxParamSetupReq->DrOffset, KZ865_MIN_RX1_DR_OFFSET, KZ865_MAX_RX1_DR_OFFSET ) == false )
+    {
+        status &= 0xFB; // Rx1DrOffset range KO
+    }
+
+    return status;
+}
+
+uint8_t RegionKZ865NewChannelReq( NewChannelReqParams_t* newChannelReq )
+{
+    uint8_t status = 0x03;
+    ChannelAddParams_t channelAdd;
+    ChannelRemoveParams_t channelRemove;
+
+    if( newChannelReq->NewChannel->Frequency == 0 )
+    {
+        channelRemove.ChannelId = newChannelReq->ChannelId;
+
+        // Remove
+        if( RegionKZ865ChannelsRemove( &channelRemove ) == false )
+        {
+            status &= 0xFC;
+        }
+    }
+    else
+    {
+        channelAdd.NewChannel = newChannelReq->NewChannel;
+        channelAdd.ChannelId = newChannelReq->ChannelId;
+
+        switch( RegionKZ865ChannelAdd( &channelAdd ) )
+        {
+            case LORAMAC_STATUS_OK:
+            {
+                break;
+            }
+            case LORAMAC_STATUS_FREQUENCY_INVALID:
+            {
+                status &= 0xFE;
+                break;
+            }
+            case LORAMAC_STATUS_DATARATE_INVALID:
+            {
+                status &= 0xFD;
+                break;
+            }
+            case LORAMAC_STATUS_FREQ_AND_DR_INVALID:
+            {
+                status &= 0xFC;
+                break;
+            }
+            default:
+            {
+                status &= 0xFC;
+                break;
+            }
+        }
+    }
+
+    return status;
+}
+
+int8_t RegionKZ865TxParamSetupReq( TxParamSetupReqParams_t* txParamSetupReq )
+{
+    return -1;
+}
+
+uint8_t RegionKZ865DlChannelReq( DlChannelReqParams_t* dlChannelReq )
+{
+    uint8_t status = 0x03;
+    uint8_t band = 0;
+
+    // Verify if the frequency is supported
+    if( VerifyTxFreq( dlChannelReq->Rx1Frequency, &band ) == false )
+    {
+        status &= 0xFE;
+    }
+
+    // Verify if an uplink frequency exists
+    if( Channels[dlChannelReq->ChannelId].Frequency == 0 )
+    {
+        status &= 0xFD;
+    }
+
+    // Apply Rx1 frequency, if the status is OK
+    if( status == 0x03 )
+    {
+        Channels[dlChannelReq->ChannelId].Rx1Frequency = dlChannelReq->Rx1Frequency;
+    }
+
+    return status;
+}
+
+int8_t RegionKZ865AlternateDr( int8_t currentDr )
+{
+    return currentDr;
+}
+
+void RegionKZ865CalcBackOff( CalcBackOffParams_t* calcBackOff )
+{
+    RegionCommonCalcBackOffParams_t calcBackOffParams;
+
+    calcBackOffParams.Channels = Channels;
+    calcBackOffParams.Bands = Bands;
+    calcBackOffParams.LastTxIsJoinRequest = calcBackOff->LastTxIsJoinRequest;
+    calcBackOffParams.Joined = calcBackOff->Joined;
+    calcBackOffParams.DutyCycleEnabled = calcBackOff->DutyCycleEnabled;
+    calcBackOffParams.Channel = calcBackOff->Channel;
+    calcBackOffParams.ElapsedTime = calcBackOff->ElapsedTime;
+    calcBackOffParams.TxTimeOnAir = calcBackOff->TxTimeOnAir;
+
+    RegionCommonCalcBackOff( &calcBackOffParams );
+}
+
+LoRaMacStatus_t RegionKZ865NextChannel( NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff )
+{
+    uint8_t nbEnabledChannels = 0;
+    uint8_t delayTx = 0;
+    uint8_t enabledChannels[KZ865_MAX_NB_CHANNELS] = { 0 };
+    TimerTime_t nextTxDelay = 0;
+
+    if( RegionCommonCountChannels( ChannelsMask, 0, 1 ) == 0 )
+    { // Reactivate default channels
+        ChannelsMask[0] |= LC( 1 ) + LC( 2 ) + LC( 3 );
+    }
+
+    if( nextChanParams->AggrTimeOff <= TimerGetElapsedTime( nextChanParams->LastAggrTx ) )
+    {
+        // Reset Aggregated time off
+        *aggregatedTimeOff = 0;
+
+        // Update bands Time OFF
+        nextTxDelay = RegionCommonUpdateBandTimeOff( nextChanParams->Joined, nextChanParams->DutyCycleEnabled, Bands, KZ865_MAX_NB_BANDS );
+
+        // Search how many channels are enabled
+        nbEnabledChannels = CountNbOfEnabledChannels( nextChanParams->Joined, nextChanParams->Datarate,
+                                                      ChannelsMask, Channels,
+                                                      Bands, enabledChannels, &delayTx );
+    }
+    else
+    {
+        delayTx++;
+        nextTxDelay = nextChanParams->AggrTimeOff - TimerGetElapsedTime( nextChanParams->LastAggrTx );
+    }
+
+    if( nbEnabledChannels > 0 )
+    {
+        // We found a valid channel
+        *channel = enabledChannels[randr( 0, nbEnabledChannels - 1 )];
+
+        *time = 0;
+        return LORAMAC_STATUS_OK;
+    }
+    else
+    {
+        if( delayTx > 0 )
+        {
+            // Delay transmission due to AggregatedTimeOff or to a band time off
+            *time = nextTxDelay;
+            return LORAMAC_STATUS_DUTYCYCLE_RESTRICTED;
+        }
+        // Datarate not supported by any channel, restore defaults
+        ChannelsMask[0] |= LC( 1 ) + LC( 2 ) + LC( 3 );
+        *time = 0;
+        return LORAMAC_STATUS_NO_CHANNEL_FOUND;
+    }
+}
+
+LoRaMacStatus_t RegionKZ865ChannelAdd( ChannelAddParams_t* channelAdd )
+{
+    uint8_t band = 0;
+    bool drInvalid = false;
+    bool freqInvalid = false;
+    uint8_t id = channelAdd->ChannelId;
+
+    if( id >= KZ865_MAX_NB_CHANNELS )
+    {
+        return LORAMAC_STATUS_PARAMETER_INVALID;
+    }
+
+    // Validate the datarate range
+    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Min, KZ865_TX_MIN_DATARATE, KZ865_TX_MAX_DATARATE ) == false )
+    {
+        drInvalid = true;
+    }
+    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Max, KZ865_TX_MIN_DATARATE, KZ865_TX_MAX_DATARATE ) == false )
+    {
+        drInvalid = true;
+    }
+    if( channelAdd->NewChannel->DrRange.Fields.Min > channelAdd->NewChannel->DrRange.Fields.Max )
+    {
+        drInvalid = true;
+    }
+
+    // Default channels don't accept all values
+    if( id < KZ865_NUMB_DEFAULT_CHANNELS )
+    {
+        // Validate the datarate range for min: must be DR_0
+        if( channelAdd->NewChannel->DrRange.Fields.Min > DR_0 )
+        {
+            drInvalid = true;
+        }
+        // Validate the datarate range for max: must be DR_5 <= Max <= TX_MAX_DATARATE
+        if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Max, DR_5, KZ865_TX_MAX_DATARATE ) == false )
+        {
+            drInvalid = true;
+        }
+        // We are not allowed to change the frequency
+        if( channelAdd->NewChannel->Frequency != Channels[id].Frequency )
+        {
+            freqInvalid = true;
+        }
+    }
+
+    // Check frequency
+    if( freqInvalid == false )
+    {
+        if( VerifyTxFreq( channelAdd->NewChannel->Frequency, &band ) == false )
+        {
+            freqInvalid = true;
+        }
+    }
+
+    // Check status
+    if( ( drInvalid == true ) && ( freqInvalid == true ) )
+    {
+        return LORAMAC_STATUS_FREQ_AND_DR_INVALID;
+    }
+    if( drInvalid == true )
+    {
+        return LORAMAC_STATUS_DATARATE_INVALID;
+    }
+    if( freqInvalid == true )
+    {
+        return LORAMAC_STATUS_FREQUENCY_INVALID;
+    }
+
+    memcpy1( ( uint8_t* )( Channels + id ), ( uint8_t* )channelAdd->NewChannel, sizeof( Channels[id] ) );
+    Channels[id].Band = band;
+    ChannelsMask[0] |= ( 1 << id );
+    return LORAMAC_STATUS_OK;
+}
+
+bool RegionKZ865ChannelsRemove( ChannelRemoveParams_t* channelRemove  )
+{
+    uint8_t id = channelRemove->ChannelId;
+
+    if( id < KZ865_NUMB_DEFAULT_CHANNELS )
+    {
+        return false;
+    }
+
+    // Remove the channel from the list of channels
+    Channels[id] = ( ChannelParams_t ){ 0, 0, { 0 }, 0 };
+
+    return RegionCommonChanDisable( ChannelsMask, id, KZ865_MAX_NB_CHANNELS );
+}
+
+void RegionKZ865SetContinuousWave( ContinuousWaveParams_t* continuousWave )
+{
+    int8_t txPowerLimited = LimitTxPower( continuousWave->TxPower, Bands[Channels[continuousWave->Channel].Band].TxMaxPower, continuousWave->Datarate, ChannelsMask );
+    int8_t phyTxPower = 0;
+    uint32_t frequency = Channels[continuousWave->Channel].Frequency;
+
+    // Calculate physical TX power
+    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, continuousWave->MaxEirp, continuousWave->AntennaGain );
+
+    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
+}
+
+uint8_t RegionKZ865ApplyDrOffset( uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset )
+{
+    int8_t datarate = dr - drOffset;
+
+    if( datarate < 0 )
+    {
+        datarate = DR_0;
+    }
+    return datarate;
+}
diff --git a/src/mac/region/RegionKZ865.h b/src/mac/region/RegionKZ865.h
new file mode 100644
index 0000000..f0d2242
--- /dev/null
+++ b/src/mac/region/RegionKZ865.h
@@ -0,0 +1,467 @@
+/*!
+ * \file      RegionKZ865.h
+ *
+ * \brief     Region definition for KZ865
+ *
+ * \copyright Revised BSD License, see section \ref LICENSE.
+ *
+ * \code
+ *                ______                              _
+ *               / _____)             _              | |
+ *              ( (____  _____ ____ _| |_ _____  ____| |__
+ *               \____ \| ___ |    (_   _) ___ |/ ___)  _ \
+ *               _____) ) ____| | | || |_| ____( (___| | | |
+ *              (______/|_____)_|_|_| \__)_____)\____)_| |_|
+ *              (C)2013-2017 Semtech
+ *
+ *               ___ _____ _   ___ _  _____ ___  ___  ___ ___
+ *              / __|_   _/_\ / __| |/ / __/ _ \| _ \/ __| __|
+ *              \__ \ | |/ _ \ (__| ' <| _| (_) |   / (__| _|
+ *              |___/ |_/_/ \_\___|_|\_\_| \___/|_|_\\___|___|
+ *              embedded.connectivity.solutions===============
+ *
+ * \endcode
+ *
+ * \author    Miguel Luis ( Semtech )
+ *
+ * \author    Gregory Cristian ( Semtech )
+ *
+ * \author    Daniel Jaeckle ( STACKFORCE )
+ *
+ * \author    Oleg Artamonov ( Unwired Devices )
+ *
+ * \defgroup  REGIONKZ865 Region KZ865
+ *            Implementation according to LoRaWAN Specification v1.0.2.
+ * \{
+ */
+#ifndef __REGION_KZ865_H__
+#define __REGION_KZ865_H__
+
+#include "LoRaMac.h"
+
+/*!
+ * LoRaMac maximum number of channels
+ */
+#define KZ865_MAX_NB_CHANNELS                       8
+
+/*!
+ * Number of default channels
+ */
+#define KZ865_NUMB_DEFAULT_CHANNELS                 3
+
+/*!
+ * Number of channels to apply for the CF list
+ */
+#define KZ865_NUMB_CHANNELS_CF_LIST                 5
+
+/*!
+ * Minimal datarate that can be used by the node
+ */
+#define KZ865_TX_MIN_DATARATE                       DR_0
+
+/*!
+ * Maximal datarate that can be used by the node
+ */
+#define KZ865_TX_MAX_DATARATE                       DR_7
+
+/*!
+ * Minimal datarate that can be used by the node
+ */
+#define KZ865_RX_MIN_DATARATE                       DR_0
+
+/*!
+ * Maximal datarate that can be used by the node
+ */
+#define KZ865_RX_MAX_DATARATE                       DR_7
+
+/*!
+ * Default datarate used by the node
+ */
+#define KZ865_DEFAULT_DATARATE                      DR_0
+
+/*!
+ * Minimal Rx1 receive datarate offset
+ */
+#define KZ865_MIN_RX1_DR_OFFSET                     0
+
+/*!
+ * Maximal Rx1 receive datarate offset
+ */
+#define KZ865_MAX_RX1_DR_OFFSET                     5
+
+/*!
+ * Default Rx1 receive datarate offset
+ */
+#define KZ865_DEFAULT_RX1_DR_OFFSET                 0
+
+/*!
+ * Minimal Tx output power that can be used by the node
+ */
+#define KZ865_MIN_TX_POWER                          TX_POWER_7
+
+/*!
+ * Maximal Tx output power that can be used by the node
+ */
+#define KZ865_MAX_TX_POWER                          TX_POWER_0
+
+/*!
+ * Default Tx output power used by the node
+ */
+#define KZ865_DEFAULT_TX_POWER                      TX_POWER_0
+
+/*!
+ * Default Max EIRP
+ */
+#define KZ865_DEFAULT_MAX_EIRP                      16.0f
+
+/*!
+ * Default antenna gain
+ */
+#define KZ865_DEFAULT_ANTENNA_GAIN                  2.15f
+
+/*!
+ * ADR Ack limit
+ */
+#define KZ865_ADR_ACK_LIMIT                         64
+
+/*!
+ * ADR Ack delay
+ */
+#define KZ865_ADR_ACK_DELAY                         32
+
+/*!
+ * Enabled or disabled the duty cycle
+ */
+#define KZ865_DUTY_CYCLE_ENABLED                    1
+
+/*!
+ * Maximum RX window duration
+ */
+#define KZ865_MAX_RX_WINDOW                         3000
+
+/*!
+ * Receive delay 1
+ */
+#define KZ865_RECEIVE_DELAY1                        1000
+
+/*!
+ * Receive delay 2
+ */
+#define KZ865_RECEIVE_DELAY2                        2000
+
+/*!
+ * Join accept delay 1
+ */
+#define KZ865_JOIN_ACCEPT_DELAY1                    5000
+
+/*!
+ * Join accept delay 2
+ */
+#define KZ865_JOIN_ACCEPT_DELAY2                    6000
+
+/*!
+ * Maximum frame counter gap
+ */
+#define KZ865_MAX_FCNT_GAP                          16384
+
+/*!
+ * Ack timeout
+ */
+#define KZ865_ACKTIMEOUT                            2000
+
+/*!
+ * Random ack timeout limits
+ */
+#define KZ865_ACK_TIMEOUT_RND                       1000
+
+#if ( KZ865_DEFAULT_DATARATE > DR_5 )
+#error "A default DR higher than DR_5 may lead to connectivity loss."
+#endif
+
+/*!
+ * Second reception window channel frequency definition.
+ */
+#define KZ865_RX_WND_2_FREQ                         866700000
+
+/*!
+ * Second reception window channel datarate definition.
+ */
+#define KZ865_RX_WND_2_DR                           DR_0
+
+/*!
+ * Maximum number of bands
+ */
+#define KZ865_MAX_NB_BANDS                          1
+
+/*!
+ * Band 0 definition
+ * { DutyCycle, TxMaxPower, LastJoinTxDoneTime, LastTxDoneTime, TimeOff }
+ */
+#define KZ865_BAND0                                 { 100 , KZ865_MAX_TX_POWER, 0, 0, 0 } //  1.0 %
+
+/*!
+ * LoRaMac default channel 1
+ * Channel = { Frequency [Hz], RX1 Frequency [Hz], { ( ( DrMax << 4 ) | DrMin ) }, Band }
+ */
+#define KZ865_LC1                                   { 865100000, 0, { ( ( DR_5 << 4 ) | DR_0 ) }, 1 }
+
+/*!
+ * LoRaMac default channel 2
+ * Channel = { Frequency [Hz], RX1 Frequency [Hz], { ( ( DrMax << 4 ) | DrMin ) }, Band }
+ */
+#define KZ865_LC2                                   { 865300000, 0, { ( ( DR_5 << 4 ) | DR_0 ) }, 1 }
+
+/*!
+ * LoRaMac default channel 2
+ * Channel = { Frequency [Hz], RX1 Frequency [Hz], { ( ( DrMax << 4 ) | DrMin ) }, Band }
+ */
+#define KZ865_LC3                                   { 865500000, 0, { ( ( DR_5 << 4 ) | DR_0 ) }, 1 }
+
+/*!
+ * LoRaMac channels which are allowed for the join procedure
+ */
+#define KZ865_JOIN_CHANNELS                         ( uint16_t )( LC( 1 ) | LC( 2 ) | LC( 3 ) )
+
+/*!
+ * Data rates table definition
+ */
+static const uint8_t DataratesKZ865[]  = { 12, 11, 10,  9,  8,  7,  7, 50 };
+
+/*!
+ * Bandwidths table definition in Hz
+ */
+static const uint32_t BandwidthsKZ865[] = { 125000, 125000, 125000, 125000, 125000, 125000, 250000, 0 };
+
+/*!
+ * Maximum payload with respect to the datarate index. Cannot operate with repeater.
+ */
+static const uint8_t MaxPayloadOfDatarateKZ865[] = { 51, 51, 51, 115, 242, 242, 242, 242 };
+
+/*!
+ * Maximum payload with respect to the datarate index. Can operate with repeater.
+ */
+static const uint8_t MaxPayloadOfDatarateRepeaterKZ865[] = { 51, 51, 51, 115, 222, 222, 222, 222 };
+
+/*!
+ * \brief The function gets a value of a specific phy attribute.
+ *
+ * \param [IN] getPhy Pointer to the function parameters.
+ *
+ * \retval Returns a structure containing the PHY parameter.
+ */
+PhyParam_t RegionKZ865GetPhyParam( GetPhyParams_t* getPhy );
+
+/*!
+ * \brief Updates the last TX done parameters of the current channel.
+ *
+ * \param [IN] txDone Pointer to the function parameters.
+ */
+void RegionKZ865SetBandTxDone( SetBandTxDoneParams_t* txDone );
+
+/*!
+ * \brief Initializes the channels masks and the channels.
+ *
+ * \param [IN] type Sets the initialization type.
+ */
+void RegionKZ865InitDefaults( InitType_t type );
+
+/*!
+ * \brief Verifies a parameter.
+ *
+ * \param [IN] verify Pointer to the function parameters.
+ *
+ * \param [IN] type Sets the initialization type.
+ *
+ * \retval Returns true, if the parameter is valid.
+ */
+bool RegionKZ865Verify( VerifyParams_t* verify, PhyAttribute_t phyAttribute );
+
+/*!
+ * \brief The function parses the input buffer and sets up the channels of the
+ *        CF list.
+ *
+ * \param [IN] applyCFList Pointer to the function parameters.
+ */
+void RegionKZ865ApplyCFList( ApplyCFListParams_t* applyCFList );
+
+/*!
+ * \brief Sets a channels mask.
+ *
+ * \param [IN] chanMaskSet Pointer to the function parameters.
+ *
+ * \retval Returns true, if the channels mask could be set.
+ */
+bool RegionKZ865ChanMaskSet( ChanMaskSetParams_t* chanMaskSet );
+
+/*!
+ * \brief Calculates the next datarate to set, when ADR is on or off.
+ *
+ * \param [IN] adrNext Pointer to the function parameters.
+ *
+ * \param [OUT] drOut The calculated datarate for the next TX.
+ *
+ * \param [OUT] txPowOut The TX power for the next TX.
+ *
+ * \param [OUT] adrAckCounter The calculated ADR acknowledgement counter.
+ *
+ * \retval Returns true, if an ADR request should be performed.
+ */
+bool RegionKZ865AdrNext( AdrNextParams_t* adrNext, int8_t* drOut, int8_t* txPowOut, uint32_t* adrAckCounter );
+
+/*!
+ * Computes the Rx window timeout and offset.
+ *
+ * \param [IN] datarate     Rx window datarate index to be used
+ *
+ * \param [IN] minRxSymbols Minimum required number of symbols to detect an Rx frame.
+ *
+ * \param [IN] rxError      System maximum timing error of the receiver. In milliseconds
+ *                          The receiver will turn on in a [-rxError : +rxError] ms
+ *                          interval around RxOffset
+ *
+ * \param [OUT]rxConfigParams Returns updated WindowTimeout and WindowOffset fields.
+ */
+void RegionKZ865ComputeRxWindowParameters( int8_t datarate, uint8_t minRxSymbols, uint32_t rxError, RxConfigParams_t *rxConfigParams );
+
+/*!
+ * \brief Configuration of the RX windows.
+ *
+ * \param [IN] rxConfig Pointer to the function parameters.
+ *
+ * \param [OUT] datarate The datarate index which was set.
+ *
+ * \retval Returns true, if the configuration was applied successfully.
+ */
+bool RegionKZ865RxConfig( RxConfigParams_t* rxConfig, int8_t* datarate );
+
+/*!
+ * \brief TX configuration.
+ *
+ * \param [IN] txConfig Pointer to the function parameters.
+ *
+ * \param [OUT] txPower The tx power index which was set.
+ *
+ * \param [OUT] txTimeOnAir The time-on-air of the frame.
+ *
+ * \retval Returns true, if the configuration was applied successfully.
+ */
+bool RegionKZ865TxConfig( TxConfigParams_t* txConfig, int8_t* txPower, TimerTime_t* txTimeOnAir );
+
+/*!
+ * \brief The function processes a Link ADR Request.
+ *
+ * \param [IN] linkAdrReq Pointer to the function parameters.
+ *
+ * \retval Returns the status of the operation, according to the LoRaMAC specification.
+ */
+uint8_t RegionKZ865LinkAdrReq( LinkAdrReqParams_t* linkAdrReq, int8_t* drOut, int8_t* txPowOut, uint8_t* nbRepOut, uint8_t* nbBytesParsed );
+
+/*!
+ * \brief The function processes a RX Parameter Setup Request.
+ *
+ * \param [IN] rxParamSetupReq Pointer to the function parameters.
+ *
+ * \retval Returns the status of the operation, according to the LoRaMAC specification.
+ */
+uint8_t RegionKZ865RxParamSetupReq( RxParamSetupReqParams_t* rxParamSetupReq );
+
+/*!
+ * \brief The function processes a Channel Request.
+ *
+ * \param [IN] newChannelReq Pointer to the function parameters.
+ *
+ * \retval Returns the status of the operation, according to the LoRaMAC specification.
+ */
+uint8_t RegionKZ865NewChannelReq( NewChannelReqParams_t* newChannelReq );
+
+/*!
+ * \brief The function processes a TX ParamSetup Request.
+ *
+ * \param [IN] txParamSetupReq Pointer to the function parameters.
+ *
+ * \retval Returns the status of the operation, according to the LoRaMAC specification.
+ *         Returns -1, if the functionality is not implemented. In this case, the end node
+ *         shall not process the command.
+ */
+int8_t RegionKZ865TxParamSetupReq( TxParamSetupReqParams_t* txParamSetupReq );
+
+/*!
+ * \brief The function processes a DlChannel Request.
+ *
+ * \param [IN] dlChannelReq Pointer to the function parameters.
+ *
+ * \retval Returns the status of the operation, according to the LoRaMAC specification.
+ */
+uint8_t RegionKZ865DlChannelReq( DlChannelReqParams_t* dlChannelReq );
+
+/*!
+ * \brief Alternates the datarate of the channel for the join request.
+ *
+ * \param [IN] currentDr Current datarate.
+ *
+ * \retval Datarate to apply.
+ */
+int8_t RegionKZ865AlternateDr( int8_t currentDr );
+
+/*!
+ * \brief Calculates the back-off time.
+ *
+ * \param [IN] calcBackOff Pointer to the function parameters.
+ */
+void RegionKZ865CalcBackOff( CalcBackOffParams_t* calcBackOff );
+
+/*!
+ * \brief Searches and set the next random available channel
+ *
+ * \param [OUT] channel Next channel to use for TX.
+ *
+ * \param [OUT] time Time to wait for the next transmission according to the duty
+ *              cycle.
+ *
+ * \param [OUT] aggregatedTimeOff Updates the aggregated time off.
+ *
+ * \retval Function status [1: OK, 0: Unable to find a channel on the current datarate]
+ */
+LoRaMacStatus_t RegionKZ865NextChannel( NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff );
+
+/*!
+ * \brief Adds a channel.
+ *
+ * \param [IN] channelAdd Pointer to the function parameters.
+ *
+ * \retval Status of the operation.
+ */
+LoRaMacStatus_t RegionKZ865ChannelAdd( ChannelAddParams_t* channelAdd );
+
+/*!
+ * \brief Removes a channel.
+ *
+ * \param [IN] channelRemove Pointer to the function parameters.
+ *
+ * \retval Returns true, if the channel was removed successfully.
+ */
+bool RegionKZ865ChannelsRemove( ChannelRemoveParams_t* channelRemove  );
+
+/*!
+ * \brief Sets the radio into continuous wave mode.
+ *
+ * \param [IN] continuousWave Pointer to the function parameters.
+ */
+void RegionKZ865SetContinuousWave( ContinuousWaveParams_t* continuousWave );
+
+/*!
+ * \brief Computes new datarate according to the given offset
+ *
+ * \param [IN] downlinkDwellTime Downlink dwell time configuration. 0: No limit, 1: 400ms
+ *
+ * \param [IN] dr Current datarate
+ *
+ * \param [IN] drOffset Offset to be applied
+ *
+ * \retval newDr Computed datarate.
+ */
+uint8_t RegionKZ865ApplyDrOffset( uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset );
+
+/*! \} defgroup REGIONKZ865 */
+
+#endif // __REGION_KZ865_H__
-- 
2.7.4

