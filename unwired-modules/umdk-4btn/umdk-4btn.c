/*
 * Copyright (C) 2016-2018 Unwired Devices LLC <info@unwds.com>

 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the Software
 * is furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
 * FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * @defgroup    
 * @ingroup     
 * @brief       
 * @{
 * @file        umdk-4btn.c
 * @brief       umdk-4btn module implementation
 * @author      Eugene Ponomarev
 */

#ifdef __cplusplus
extern "C" {
#endif

/* define is autogenerated, do not change */
#undef _UMDK_MID_
#define _UMDK_MID_ UNWDS_4BTN_MODULE_ID

/* define is autogenerated, do not change */
#undef _UMDK_NAME_
#define _UMDK_NAME_ "4btn"

#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <limits.h>

#include "periph/gpio.h"

#include "board.h"

#include "umdk-ids.h"
#include "unwds-common.h"
#include "umdk-4btn.h"

#include "thread.h"
#include "rtctimers-millis.h"

static kernel_pid_t handler_pid;

#define UMDK_4BTN_NUM_BUTTONS 4
static gpio_t buttons[UMDK_4BTN_NUM_BUTTONS] = {UMDK_4BTN_1, UMDK_4BTN_2, UMDK_4BTN_3, UMDK_4BTN_4};

static uwnds_cb_t *callback;

static void *handler(void *arg) {
    (void)arg;
    
    msg_t msg;
    msg_t msg_queue[4];
    msg_init_queue(msg_queue, 4);

    while (1) {
        msg_receive(&msg);
        int btn = msg.type;

        module_data_t data;
        data.length = 4;
        data.data[0] = _UMDK_MID_;
        data.data[1] = UMDK_4BTN_DATA;
        data.data[2] = (btn & 0xFF) + 1;
        data.data[3] = (btn >> 15);

        callback(&data);
    }

    return NULL;
}

static void btn_pressed_int(void *arg) {
    int btn_num = (int) arg;
    
    gpio_irq_disable(buttons[btn_num]);
    
    uint8_t now_value = 0;
    uint8_t last_value = gpio_read(buttons[btn_num]);

    uint8_t value_counter = 0;
    uint8_t error_counter = 0;
    
    do {
        rtctimers_millis_sleep(10);
        now_value = gpio_read(buttons[btn_num]);
        
        if (now_value == last_value) {
            value_counter++;
            last_value = now_value;
        } else {
            value_counter = 0;
            error_counter++;
        }
    } while ((value_counter < 5) && (error_counter < 100));
    
    if (error_counter == 100) {
        puts("[umdk-" _UMDK_NAME_ "] Press rejected");
        gpio_irq_enable(buttons[btn_num]);
        return;
    }
    
    msg_t msg;
    msg.type = btn_num;
    if (last_value) {
        /* button released */
        msg.type |= 1 << 15;
        printf("[umdk-" _UMDK_NAME_ "] Released: %d\n", btn_num + 1);
    } else {
        printf("[umdk-" _UMDK_NAME_ "] Pressed: %d\n", btn_num + 1);
    }

    msg_send_int(&msg, handler_pid);
    
    gpio_irq_enable(buttons[btn_num]);
}

void umdk_4btn_init(uwnds_cb_t *event_callback) {
    callback = event_callback;

    /* Initialize interrupts */
    int i = 0;
    for (i = 0; i < UMDK_4BTN_NUM_BUTTONS; i++) {
        gpio_init_int(buttons[i], GPIO_IN_PU, GPIO_BOTH, btn_pressed_int, (void *) i);
    }

    /* Create handler thread */
    char *stack = (char *) allocate_stack(UMDK_4BTN_STACK_SIZE);
    if (!stack) {
        return;
    }

    handler_pid = thread_create(stack, UMDK_4BTN_STACK_SIZE, THREAD_PRIORITY_MAIN - 1, THREAD_CREATE_STACKTEST, handler, NULL, "4btn thread");
}

bool umdk_4btn_cmd(module_data_t *data, module_data_t *reply) {
    (void)data;
    (void)reply;
    return false;
}

#ifdef __cplusplus
}
#endif
