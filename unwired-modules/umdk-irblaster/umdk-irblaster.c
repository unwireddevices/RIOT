/*
 * Copyright (C) 2017 Unwired Devices [info@unwds.com]
 *
 * This file is subject to the terms and conditions of the GNU Lesser
 * General Public License v2.1. See the file LICENSE in the top level
 * directory for more details.
 */

/**
 * @defgroup
 * @ingroup
 * @brief
 * @{
 * @file	    umdk-irblaster.c
 * @brief       umdk-irblaster module implementation
 * @author      Oleg Artamonov
 */

#ifdef __cplusplus
extern "C" {
#endif

/* define is autogenerated, do not change */
#undef _UMDK_MID_
#define _UMDK_MID_ UNWDS_IRBLASTER_MODULE_ID

/* define is autogenerated, do not change */
#undef _UMDK_NAME_
#define _UMDK_NAME_ "irblaster"

#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <limits.h>

#include "board.h"
#include "xtimer.h"
#include "periph/gpio.h"

#include "unwds-common.h"
#include "utils.h"
#include "include/umdk-irblaster.h"

static const uint16_t koeff_duty = (uint16_t)(UMDK_IR_RES_DEFAULT / UMDK_IR_DUTY_MAX);

static uint32_t freq = 38000; /* PWM device frequency */
static uint8_t dev_id = 0; /* PWM device ID */
static uint8_t ch_num = 1; /* channel number */
static uint8_t duty_value = 50; /* duty cycle 50 % */

static umdk_irblaster_dev_t *dev;
static umdk_irblaster_ch_t *ch;

static umdk_irblaster_dev_t pwm_devs[UMDK_IR_NUM_DEVS] = {
			{
				.dev      	= UMDK_IR_0,
				.num_chan 	= UMDK_IR_0_NUM_CH_MAX,
				.mode 	  	= PWM_LEFT,
				.freq 		= UMDK_IR_FREQ_DEFAULT,
				.res 		= UMDK_IR_RES_DEFAULT,

				.pwm_chs[0] = { UMDK_IR_CH_0, UMDK_IR_STATUS_DEFAULT, UMDK_IR_DUTY_DEFAULT },
				.pwm_chs[1] = { UMDK_IR_CH_1, UMDK_IR_STATUS_DEFAULT, UMDK_IR_DUTY_DEFAULT },
				.pwm_chs[2] = { UMDK_IR_CH_2, UMDK_IR_STATUS_DEFAULT, UMDK_IR_DUTY_DEFAULT },
				.pwm_chs[3] = { UMDK_IR_CH_3, UMDK_IR_STATUS_DEFAULT, UMDK_IR_DUTY_DEFAULT },

				.is_started = false
			},
			{
				.dev      	= UMDK_IR_1,
				.num_chan 	= UMDK_IR_1_NUM_CH_MAX,
				.mode 	  	= PWM_LEFT,
				.freq 		= UMDK_IR_FREQ_DEFAULT,
				.res 		= UMDK_IR_RES_DEFAULT,

				.pwm_chs[0] = { UMDK_IR_CH_0, UMDK_IR_STATUS_DEFAULT, UMDK_IR_DUTY_DEFAULT },
				.pwm_chs[1] = { UMDK_IR_CH_1, UMDK_IR_STATUS_DEFAULT, UMDK_IR_DUTY_DEFAULT },

				.is_started = false
			},
			{
				.dev      	= UMDK_IR_2,
				.num_chan 	= UMDK_IR_2_NUM_CH_MAX,
				.mode 	  	= PWM_LEFT,
				.freq 		= UMDK_IR_FREQ_DEFAULT,
				.res 		= UMDK_IR_RES_DEFAULT,

				.pwm_chs[0] = { UMDK_IR_CH_2, UMDK_IR_STATUS_DEFAULT, UMDK_IR_DUTY_DEFAULT },
				.pwm_chs[1] = { UMDK_IR_CH_3, UMDK_IR_STATUS_DEFAULT, UMDK_IR_DUTY_DEFAULT },

				.is_started = false
			},
};

static void send_start(void) {
    gpio_init_af(pwm_config[dev_id].pins[ch->ch], pwm_config[dev_id].af);
    xtimer_spin(xtimer_ticks_from_usec(3700));
    gpio_init_af(pwm_config[dev_id].pins[ch->ch], 0);
    xtimer_spin(xtimer_ticks_from_usec(1800));
}

static void send_byte(uint8_t data) {
    int bit;
    for (bit = 7; bit >= 0; bit --) {
        gpio_init_af(pwm_config[dev_id].pins[ch->ch], pwm_config[dev_id].af);
        xtimer_spin(xtimer_ticks_from_usec(350));
        gpio_init_af(pwm_config[dev_id].pins[ch->ch], 0);
        if (data & (1 << bit)) {
            xtimer_spin(xtimer_ticks_from_usec(1400));
        } else {
            xtimer_spin(xtimer_ticks_from_usec(500));
        }
    }
}

int umdk_irblaster_shell_cmd(int argc, char **argv) {
    if (argc == 1) {
        puts (_UMDK_NAME_ " send <data> - send data (ascii-hex) to IR port");
        return 0;
    }
    
    char *cmd = argv[1];
	
    if (strcmp(cmd, "send") == 0) {
        if (argc < 3) {
            puts ("[" _UMDK_NAME_ "] no data to send");
            return 0;
        }
        char *hex = argv[2];
        if (strlen(hex) > 50*2) {
            puts ("[" _UMDK_NAME_ "] too much data");
            return 0;
        }
        
        uint8_t data[50];
        if (!hex_to_bytes(hex, data, false)) {
            puts ("[" _UMDK_NAME_ "] invalid hex data");
            return 0;
        }
        
        send_start();
        int byte;
        for (byte = 0; byte < strlen(hex)/2; byte++) {
            send_byte(data[byte]);
        }
        
        puts ("[" _UMDK_NAME_ "] data successfully sent");
    } else {
        puts ("[" _UMDK_NAME_ "] unknown command");
    }
    
    return 1;
}

static inline void update_pwm_freq(umdk_irblaster_dev_t *dev, uint32_t freq)
{
    dev->freq = freq;

    pwm_stop(dev->dev);
    pwm_init(dev->dev, dev->mode, dev->freq, dev->res);
}

static void set_pwm_value(umdk_irblaster_dev_t *dev, umdk_irblaster_ch_t *ch, uint8_t value)
{
    ch->duty_cycle = (uint16_t)(value * koeff_duty);

    /*
     * Check that device for corresponding channel is need to be started or can be stopped.
     * We could stop the PWM device if all it's channels are not initialization
     */
    bool need_to_start = !dev->is_started;
    bool can_be_stopped = true;

    uint8_t channel = ch->ch;

    for (int i = 0; i < dev->num_chan; i++) {
        umdk_irblaster_ch_t *chan = &(dev->pwm_chs[i]);
		/* Device can't be stopped if it has initialization channels */
		if (chan->status == UMDK_IR_CH_TURN_ON) {
			can_be_stopped = false;
		}
    }

    if (can_be_stopped) {
		/* Stop current device if it was started */
		if (dev->is_started) {
			pwm_stop(dev->dev);
			dev->is_started = false;

			printf("[umdk-" _UMDK_NAME_ "] PWM device #%d is stopped\n", dev->dev);
		}
		else {
			printf("[umdk-" _UMDK_NAME_ "] PWM device #%d is not work now\n", dev->dev);
		}
    }
    else {
	  /* Start or continue work current PWM device */
	  if (need_to_start) {
		pwm_start(dev->dev);
		dev->is_started = true;
		printf("[umdk-" _UMDK_NAME_ "] PWM device #%d is started\n", dev->dev);
	  }

	  /* Set value for the current channel in current PWM device if it's running */
	   if (dev->is_started) {
		pwm_set(dev->dev, channel, ch->duty_cycle);
		printf("[umdk-" _UMDK_NAME_ "] Set PWM device #%d channel #%d to %d%%(%d)\n", dev->dev, channel, value, ch->duty_cycle);
	   }
    }
}

static inline void umdk_irblaster_turn_off_pin(gpio_t pin)
{
	GPIO_TypeDef *port = (GPIO_TypeDef *)( pin & ~(0x0F));
	int pin_num =  ( pin & 0x0F );

	/* disable pull-up on GPIO */
	port->PUPDR &= ~(0x3 << (2 * pin_num));
	/*  Set analog mode */
	port->MODER &= ~(0x3 << (2 * pin_num));
	port->MODER |= (0x3 << (2 * pin_num));
}

static inline void reply_error(module_data_t *reply) 
{
	reply->as_ack = true;
	reply->length = 2;
	reply->data[0] = _UMDK_MID_;
	reply->data[1] = 1;
}

static inline void reply_ok(module_data_t *reply)
{
	reply->as_ack = true;	
	reply->length = 2;
	reply->data[0] = _UMDK_MID_;
	reply->data[1] = 0;
}

bool umdk_irblaster_cmd(module_data_t *cmd, module_data_t *reply)
{
    umdk_irblaster_cmd_t c = (cmd->data[0] >> 4) & 0x0F;

    switch (c) {
        case UMDK_IR_CMD_SEND: {
            uint8_t data_size_bytes = cmd->data[1];
            send_start();
            int byte;
            for (byte = 0; byte < data_size_bytes; byte++) {
                send_byte(cmd->data[2+byte]);
            }
            
            reply_ok(reply);
        
			return true;
			break;
        }
		default:
        break;
    }

    return false;
}

static uwnds_cb_t *callback;

void umdk_irblaster_init(uint32_t *non_gpio_pin_map, uwnds_cb_t *event_callback)
{
    (void)non_gpio_pin_map;

    callback = event_callback;
    
    dev = &pwm_devs[dev_id];
    ch = &(dev->pwm_chs[ch_num]);
    
    pwm_init(dev->dev, dev->mode, dev->freq, dev->res);
    pwm_stop(dev->dev);
    
    gpio_init(pwm_config[dev_id].pins[ch->ch], GPIO_OUT);
    gpio_init_af(pwm_config[dev_id].pins[ch->ch], pwm_config[dev_id].af);
    ch->status = UMDK_IR_CH_TURN_ON;
    printf("[umdk-" _UMDK_NAME_ "] IR device #%d channel %d turned on\n", dev_id, ch_num);
    update_pwm_freq(dev, freq);
    set_pwm_value(dev, ch, duty_value);

    /* disable PWM for now */
    gpio_init_af(pwm_config[dev_id].pins[ch->ch], 0);
    
    unwds_add_shell_command( _UMDK_NAME_, "type '" _UMDK_NAME_ "' for commands list", umdk_irblaster_shell_cmd);
}

#ifdef __cplusplus
}
#endif
