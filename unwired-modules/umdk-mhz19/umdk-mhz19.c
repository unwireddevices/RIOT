/*
 * Copyright (C) 2017 Unwired Devices [info@unwds.com]
 *
 * This file is subject to the terms and conditions of the GNU Lesser
 * General Public License v2.1. See the file LICENSE in the top level
 * directory for more details.
 */

/**
 * @defgroup
 * @ingroup
 * @brief
 * @{
 * @file		umdk-mhz19.c
 * @brief       umdk-mhz19 module implementation
 * @author      Dmitry Golik
 */

#ifdef __cplusplus
extern "C" {
#endif

/* define is autogenerated, do not change */
#undef _UMDK_MID_
#define _UMDK_MID_ UNWDS_MHZ19_MODULE_ID

/* define is autogenerated, do not change */
#undef _UMDK_NAME_
#define _UMDK_NAME_ "mhz19"

#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

#include "board.h"

#include "unwds-common.h"
#include "include/umdk-mhz19.h"

#include "mhz19.h"

#include "thread.h"
#include "xtimer.h"
#include "rtctimers.h"

#define ENABLE_DEBUG (0)
#include "debug.h"

static mhz19_t mhz19;

static uwnds_cb_t *callback;

typedef struct {
    uint8_t publish_period_sec;
} umdk_mhz19_config_t;

static umdk_mhz19_config_t umdk_mhz19_config = { .publish_period_sec = 5};

static bool is_polled = false;
static rtctimer_t timer;
static msg_t timer_msg = {};
static kernel_pid_t timer_pid;

static void *timer_thread(void *arg) {
    msg_t msg;
    msg_t msg_queue[4];
    msg_init_queue(msg_queue, 4);
    
    printf("[umdk-" _UMDK_NAME_ "] Periodic publisher thread started, period is %d min\n", umdk_mhz19_config.publish_period_sec/60);

    while (1) {
        msg_receive(&msg);

        mhz19_get(&mhz19);

        /* Restart after delay */
        rtctimers_set_msg(&timer, umdk_mhz19_config.publish_period_sec, &timer_msg, timer_pid);
    }
    return NULL;
}

void mhz19_cb(mhz19_data_t mhz19_data)
{
    module_data_t data;
    data.data[0] = _UMDK_MID_;
    data.length = 1;
    
    int16_t measurements[2];
    
    measurements[0] = mhz19_data.co2;
    measurements[1] = mhz19_data.temperature;
    uint8_t validity = mhz19_data.validity;
    
    printf("[umdk-" _UMDK_NAME_ "] CO2: %d, temperature: %d, validity: %d\n",
            measurements[0], measurements[1], (int)validity);
    
    
    measurements[1] *= 10;
    memcpy((void *)&data.data[data.length], measurements, sizeof(measurements));
    data.length += sizeof(measurements);

    data.data[data.length] = validity;
    data.length++;

    data.as_ack = is_polled;
    is_polled = false;

    callback(&data);
    
    return;
}

static void reset_config(void) {
    umdk_mhz19_config.publish_period_sec = 60;
}

static void init_config(void) {
	reset_config();

	if (!unwds_read_nvram_config(_UMDK_MID_, (uint8_t *) &umdk_mhz19_config, sizeof(umdk_mhz19_config)))
		reset_config();
}

static inline void save_config(void) {
	unwds_write_nvram_config(_UMDK_MID_, (uint8_t *) &umdk_mhz19_config, sizeof(umdk_mhz19_config));
}

int umdk_mhz19_shell_cmd(int argc, char **argv) {
    if (argc == 1) {
        puts ("mhz19 send - ask MH-Z19 for CO2 concentration (equivalent to mhz19 send 01030105000455f4 )");
        puts ("mhz19 period <period> - set publishing period");
        puts ("mhz19 reset - reset settings to default");
        return 0;
    }
    
    char *cmd = argv[1];
    
    if (strcmp(cmd, "send") == 0) {
        mhz19_get(&mhz19);
    }
    
    if (strcmp(cmd, "period") == 0) {
        char *val = argv[2];
        umdk_mhz19_config.publish_period_sec = atoi(val);
        save_config();
    }
    
    if (strcmp(cmd, "reset") == 0) {
        reset_config();
        save_config();
    }
    
    return 1;
}

void umdk_mhz19_init(uint32_t *non_gpio_pin_map, uwnds_cb_t *event_callback)
{
    (void) non_gpio_pin_map;
    callback = event_callback;

    init_config();
    
    mhz19.reader_stack = (uint8_t *) allocate_stack(UMDK_MHZ19_READER_STACK_SIZE);
    if (!mhz19.reader_stack) {
        puts("[umdk-" _UMDK_NAME_ "] Unable to allocate memory. Is too many modules enabled?");
        return;
    }
    
    mhz19_param_t mhz19_params;
    mhz19_params.mhz19_cb = mhz19_cb;
    mhz19_params.uart = UMDK_MHZ19_UART;

    if (!mhz19_init(&mhz19, &mhz19_params)) {
        puts("[umdk-" _UMDK_NAME_ "] Error initializing driver");
        return;
    }

    char *timer_stack = (char *) allocate_stack(UMDK_MHZ19_STACK_SIZE);
    if (!timer_stack) {
        puts("[umdk-" _UMDK_NAME_ "] Unable to allocate memory. Is too many modules enabled?");
        return;
    }
    timer_pid = thread_create(timer_stack, UMDK_MHZ19_STACK_SIZE, THREAD_PRIORITY_MAIN - 1, THREAD_CREATE_STACKTEST, timer_thread, NULL, "umdk-mhz19 timer thread");
    /* Start publishing timer */
    rtctimers_set_msg(&timer, umdk_mhz19_config.publish_period_sec, &timer_msg, timer_pid);

    unwds_add_shell_command("mhz19", "type 'mhz19' for commands list", umdk_mhz19_shell_cmd);

}

static void do_reply(module_data_t *reply, umdk_mhz19_reply_t r)
{
    reply->length = 2;
    reply->data[0] = _UMDK_MID_;
    reply->data[1] = r;
}

bool umdk_mhz19_cmd(module_data_t *data, module_data_t *reply)
{
    if (data->length < 1) {
        do_reply(reply, UMDK_MHZ19_REPLY_ERR_FMT);
        return true;
    }

    umdk_mhz19_prefix_t prefix = data->data[0];
    switch (prefix) {
        case UMDK_MHZ19_ASK:
            is_polled = true;
            // umdk_mhz19_ask();
            msg_send(&timer_msg, timer_pid);
        case UMDK_MHZ19_SET_PERIOD:
            if (data->length != 2) {
                do_reply(reply, UMDK_MHZ19_REPLY_ERR_FMT);
                break;
            }

            umdk_mhz19_config.publish_period_sec = 60*(data->data[1]);
            do_reply(reply, UMDK_MHZ19_REPLY_OK);
            break;

        default:
        	do_reply(reply, UMDK_MHZ19_REPLY_ERR_FMT);
        	break;
    }

    return true;
}

#ifdef __cplusplus
}
#endif
