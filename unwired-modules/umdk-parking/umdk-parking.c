/*
 * Copyright (C) 2016-2018 Unwired Devices LLC <info@unwds.com>

 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the Software
 * is furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
 * FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * @defgroup    
 * @ingroup     
 * @brief       
 * @{
 * @file		umdk-parking.c
 * @brief       umdk-parking module implementation
 * @author      Oleg Artamonov <info@unwds.com>
 */

#ifdef __cplusplus
extern "C" {
#endif

/* define is autogenerated, do not change */
#undef _UMDK_MID_
#define _UMDK_MID_ UNWDS_PARKING_MODULE_ID

/* define is autogenerated, do not change */
#undef _UMDK_NAME_
#define _UMDK_NAME_ "parking"

#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include "byteorder.h"

#include "periph/gpio.h"
#include "periph/i2c.h"

#include "board.h"

#include "lis3mdl.h"
#include "lis3mdl_params.h"

#include "umdk-ids.h"
#include "unwds-common.h"
#include "umdk-parking.h"

#include "thread.h"
#include "lptimer.h"

static lis3mdl_t dev;

static uwnds_cb_t *callback;

static kernel_pid_t timer_pid;

static msg_t send_msg = { .content.value = 0 };
static msg_t detect_msg = { .content.value = 1 };
static lptimer_t timer_send;
static lptimer_t timer_detect;

static bool is_polled = false;

int vehicle_detection = 0;
bool vehicle_detected = false;

static struct {
	uint16_t publish_period_sec;
    uint16_t rate;
	uint8_t i2c_dev;
    uint8_t threshold;
    int32_t zero;
} parking_config;

static bool init_sensor(void) {
	lis3mdl_params_t lis3mdl_params;
    
    lis3mdl_params.i2c = UMDK_PARKING_I2C;              /**< I2C device */
    lis3mdl_params.addr = 0x1C;                         /**< Magnetometer I2C address */
    lis3mdl_params.xy_mode = LIS3MDL_XY_MODE_MEDIUM;    /**< Power mode of x- and y-axis */
    lis3mdl_params.z_mode = LIS3MDL_Z_MODE_MEDIUM;      /**< Power mode of z-axis */
    lis3mdl_params.odr = LIS3MDL_ODR_80HZ;              /**< Output data rate */
    lis3mdl_params.scale = LIS3MDL_SCALE_4G;            /**< Scale factor */
    lis3mdl_params.op_mode = LIS3MDL_OP_SNGL_CONV;      /**< Operation mode */

	printf("[umdk-" _UMDK_NAME_ "] Initializing LIS3MDL on I2C #%d\n", lis3mdl_params.i2c);

    if (lis3mdl_init(&dev, &lis3mdl_params) == 0) {
        lis3mdl_poweroff(&dev);
        return true;
    }
    
    return false;
}

static void prepare_result(module_data_t *buf) {
	lis3mdl_3d_data_t mag_value;
    
    lis3mdl_poweron(&dev);
    lis3mdl_read_mag(&dev, &mag_value);
    
    int16_t temp_value;
    lis3mdl_read_temp(&dev, &temp_value);
    lis3mdl_poweroff(&dev);
    
    printf("Magnetometer [mG]:\tX: %2d\tY: %2d\tZ: %2d\n",
           mag_value.x_axis,
           mag_value.y_axis,
           mag_value.z_axis);

    printf("Temperature:\t\t%i C\n", temp_value);
    
    int16_t z;
    z = mag_value.z_axis - parking_config.zero;
    
    if (z < -parking_config.threshold - 100) {
        if (vehicle_detection < 5) {
            vehicle_detection ++;
        }
    } else {
        if (vehicle_detection) {
            vehicle_detection--;
        }
    }

    int16_t mask;
    uint16_t le;
    
    if (buf) {
        buf->data[0] = _UMDK_MID_;
        buf->data[1] = UMDK_PARKING_DATA;
        buf->length = 2;
        
        if (vehicle_detection == 5) {
            buf->data[buf->length] = 1;
        }
        
        if ((vehicle_detected) && (vehicle_detection > 0)) {
            buf->data[buf->length] = 1;
        }
        
        if (vehicle_detection == 0) {
            buf->data[buf->length] = 0;
        }
        
        buf->length += 1;
        
        mask = mag_value.x_axis >> 15;
        le = ((mag_value.x_axis + mask) ^ mask) | (mag_value.x_axis & 0x8000);
        byteorder_swap(&le, sizeof(le));
        memcpy(&buf->data[buf->length], (void *)&le, sizeof(le));
        buf->length += sizeof(le);
        
        mask = mag_value.y_axis >> 15;
        le = ((mag_value.y_axis + mask) ^ mask) | (mag_value.y_axis & 0x8000);
        byteorder_swap(&le, sizeof(le));
        memcpy(&buf->data[buf->length], (void *)&le, 2);
        buf->length += sizeof(le);
        
        mask = mag_value.z_axis >> 15;
        le = ((mag_value.z_axis + mask) ^ mask) | (mag_value.y_axis & 0x8000);
        byteorder_swap(&le, sizeof(le));
        memcpy(&buf->data[buf->length], (void *)&le, 2);
        buf->length += sizeof(le);
    }
}

static void *timer_thread(void *arg) {
    (void)arg;
    
    msg_t msg;
    msg_t msg_queue[4];
    msg_init_queue(msg_queue, 4);
    
    puts("[umdk-" _UMDK_NAME_ "] Periodic publisher thread started");

    while (1) {
        msg_receive(&msg);

        module_data_t data = {};
        data.as_ack = is_polled;
        is_polled = false;

        puts("[umdk-" _UMDK_NAME_ "] Getting data");
        prepare_result(&data);

        switch (msg.content.value) {
            case 0:
                puts("[umdk-" _UMDK_NAME_ "] Sending data on timer");
                callback(&data);
                lptimer_set_msg(&timer_send, 1000 * parking_config.publish_period_sec, &send_msg, timer_pid);
            break;
            case 1:
                if ((data.data[2] == 1) && (!vehicle_detected)) {
                    data.data[1] = UMDK_PARKING_ALARM;
                    puts("[umdk-" _UMDK_NAME_ "] Sending data immediately");
                    callback(&data);
                    vehicle_detected = true;
                }
                if ((data.data[2] == 0) && (vehicle_detected)) {
                    data.data[1] = UMDK_PARKING_ALARM;
                    puts("[umdk-" _UMDK_NAME_ "] Sending data immediately");
                    callback(&data);
                    vehicle_detected = false;
                }
                lptimer_set_msg(&timer_detect, 1000 * parking_config.rate, &detect_msg, timer_pid);
                break;
            default:
                break;
        }
    }

    return NULL;
}

static void reset_config(void) {
	parking_config.publish_period_sec = UMDK_PARKING_PUBLISH_PERIOD_SEC;
	parking_config.i2c_dev = UMDK_PARKING_I2C;
    parking_config.threshold = 100;
    parking_config.rate = UMDK_PARKING_RATE_SEC;
    parking_config.zero = -450;
}

static void init_config(void) {
	reset_config();

	if (!unwds_read_nvram_config(_UMDK_MID_, (uint8_t *) &parking_config, sizeof(parking_config)))
		reset_config();

	if (parking_config.i2c_dev >= I2C_NUMOF) {
		reset_config();
		return;
	}
}

static inline void save_config(void) {
	unwds_write_nvram_config(_UMDK_MID_, (uint8_t *) &parking_config, sizeof(parking_config));
}

static void set_period (int period) {
    lptimer_remove(&timer_send);

    parking_config.publish_period_sec = period;
	save_config();

	/* Don't restart timer if new period is zero */
	if (parking_config.publish_period_sec) {
        lptimer_set_msg(&timer_send, 1000 * parking_config.publish_period_sec, &send_msg, timer_pid);
		printf("[umdk-" _UMDK_NAME_ "] Period set to %d sec\n", parking_config.publish_period_sec);
    } else {
        puts("[umdk-" _UMDK_NAME_ "] Timer stopped");
    }
}

static void set_zero(void)
{
    lis3mdl_3d_data_t mag_value;
    
    lis3mdl_read_mag(&dev, &mag_value);
    
    printf("Magnetometer [mG]:\tX: %2d\tY: %2d\tZ: %2d\n",
               mag_value.x_axis,
               mag_value.y_axis,
               mag_value.z_axis);
               
    printf("[umdk-" _UMDK_NAME_ "] Zero set to %d mg\n", mag_value.z_axis);
    parking_config.zero = mag_value.z_axis;
	save_config();
}

static void set_rate (int rate) {
    printf("[umdk-" _UMDK_NAME_ "] Rate set to %d sec\n", rate);
    parking_config.rate = rate;
	save_config();
    
    lptimer_remove(&timer_detect);
    lptimer_set_msg(&timer_detect, 1000 * parking_config.rate, &detect_msg, timer_pid);
}

static void set_threshold (int threshold) {
    printf("[umdk-" _UMDK_NAME_ "] Threshold set to %d mgauss\n", threshold);
    parking_config.threshold = threshold;
	save_config();
}

int umdk_parking_shell_cmd(int argc, char **argv) {
    if (argc == 1) {
        puts (_UMDK_NAME_ " get - get results now");
        puts (_UMDK_NAME_ " send - get and send results now");
        puts (_UMDK_NAME_ " period <N> - set period to N seconds");
        puts (_UMDK_NAME_ " rate <N> - set rate to N seconds");
        puts (_UMDK_NAME_ " zero - set relative Z axis zero");
        puts (_UMDK_NAME_ " reset - reset settings to default");
        return 0;
    }
    
    char *cmd = argv[1];
	
    if (strcmp(cmd, "get") == 0) {
        prepare_result(NULL);
    }
    
    if (strcmp(cmd, "send") == 0) {
		/* Send signal to publisher thread */
		msg_send(&send_msg, timer_pid);
    }
    
    if (strcmp(cmd, "period") == 0) {
        char *val = argv[2];
        set_period(atoi(val));
    }
    
    if (strcmp(cmd, "rate") == 0) {
        char *val = argv[2];
        set_rate(atoi(val));
    }
    
    if (strcmp(cmd, "zero") == 0) {
        set_zero();
    }
    
    if (strcmp(cmd, "reset") == 0) {
        reset_config();
        save_config();
    }
    
    return 1;
}

void umdk_parking_init(uwnds_cb_t *event_callback) {
	callback = event_callback;

	init_config();

	if (!init_sensor()) {
		puts("[umdk-" _UMDK_NAME_ "] Unable to init sensor!");
        return;
	} else {
        puts("[umdk-" _UMDK_NAME_ "] Sensor initialized");
    }

	/* Create handler thread */
	char *stack = (char *) allocate_stack(UMDK_PARKING_STACK_SIZE);
	if (!stack) {
		puts("[umdk-" _UMDK_NAME_ "] unable to allocate memory. Are too many modules enabled?");
		return;
	}
    
    unwds_add_shell_command( _UMDK_NAME_, "type '" _UMDK_NAME_ "' for commands list", umdk_parking_shell_cmd);

	timer_pid = thread_create(stack, UMDK_PARKING_STACK_SIZE, THREAD_PRIORITY_MAIN - 1, THREAD_CREATE_STACKTEST, timer_thread, NULL, "parking thread");

    /* Start publishing timer */
	lptimer_set_msg(&timer_send, 1000 * parking_config.publish_period_sec, &send_msg, timer_pid);
    
    /* Start measurement timer */
    lptimer_set_msg(&timer_detect, 1000 * parking_config.rate, &detect_msg, timer_pid);
    
    printf("[umdk-" _UMDK_NAME_ "] Publish period: %d sec\n", parking_config.publish_period_sec);
    printf("[umdk-" _UMDK_NAME_ "] Measurement period: %d sec\n", parking_config.rate);
}

static void reply_fail(module_data_t *reply) {
	reply->data[0] = _UMDK_MID_;
	reply->data[1] = UMDK_PARKING_FAIL;
    reply->length = 2;
}

static void reply_ok(module_data_t *reply) {
	reply->data[0] = _UMDK_MID_;
	reply->data[1] = UMDK_PARKING_CONFIG;
    reply->length = 2;
    
    uint16_t period = parking_config.publish_period_sec;
    uint16_t rate = parking_config.rate;
    uint8_t threshold = parking_config.threshold;
    
    convert_to_be_sam((void *)&period, sizeof(period));
    convert_to_be_sam((void *)&rate, sizeof(rate));
    
    memcpy(&reply->data[1], (void *)&period, sizeof(period));
    reply->length += sizeof(period);
    
    memcpy(&reply->data[3], (void *)&rate, sizeof(rate));
    reply->length += sizeof(rate);
    
    memcpy(&reply->data[5], (void *)&threshold, sizeof(threshold));
    reply->length += sizeof(threshold);
}

bool umdk_parking_cmd(module_data_t *cmd, module_data_t *reply) {
    if ((cmd->data[0] == UMDK_PARKING_CONFIG) && (cmd->length == 6)) {
        int16_t rate = cmd->data[1] | cmd->data[2] << 8;
        convert_from_be_sam((void *)&rate, sizeof(rate));
        if (rate > 0) {
            set_rate(rate);
        } else {
            puts("[umdk-" _UMDK_NAME_ "] rate: do not change");
        }

        int16_t period = cmd->data[3] | cmd->data[4] << 8;
        convert_from_be_sam((void *)&period, sizeof(period));
        if (period > 0) {
            set_period(period);
        } else {
            puts("[umdk-" _UMDK_NAME_ "] period: do not change");
        }
        
        uint8_t threshold = cmd->data[5];
        if (threshold) {
            set_threshold(threshold);
        } else {
            puts("[umdk-" _UMDK_NAME_ "] threshold: do not change");
        }

        reply_ok(reply);
        return true;
    }
    
    reply_fail(reply);

	return true;
}

#ifdef __cplusplus
}
#endif
